diff --git a/content/browser/renderer_host/render_frame_host_manager.cc b/content/browser/renderer_host/render_frame_host_manager.cc
index abe9ae05e7b5..655d52f81dc5 100644
--- a/content/browser/renderer_host/render_frame_host_manager.cc
+++ b/content/browser/renderer_host/render_frame_host_manager.cc
@@ -496,28 +496,6 @@ void RenderFrameHostManager::UnloadOldFrame(
   // RenderFrameHost should not be trying to commit a navigation.
   old_render_frame_host->ResetNavigationRequests();
 
-  NavigationEntryImpl* last_committed_entry =
-      delegate_->GetControllerForRenderManager().GetLastCommittedEntry();
-  BackForwardCacheMetrics* old_page_back_forward_cache_metrics =
-      (!old_render_frame_host->GetParent() && last_committed_entry)
-          ? last_committed_entry->back_forward_cache_metrics()
-          : nullptr;
-
-  // Record the metrics about the state of the old main frame at the moment when
-  // we navigate away from it as it matters for whether the page is eligible for
-  // being put into back-forward cache.
-  //
-  // This covers the cross-process navigation case and the same-process case is
-  // handled in RenderFrameHostImpl::CommitNavigation, so the subframe state
-  // can be captured before the frame navigates away.
-  //
-  // TODO(altimin, crbug.com/933147): Remove this logic after we are done with
-  // implementing back-forward cache.
-  if (old_page_back_forward_cache_metrics) {
-    old_page_back_forward_cache_metrics->RecordFeatureUsage(
-        old_render_frame_host.get());
-  }
-
   // BackForwardCache:
   //
   // If the old RenderFrameHost can be stored in the BackForwardCache, return
@@ -566,9 +544,6 @@ void RenderFrameHostManager::UnloadOldFrame(
       back_forward_cache.StoreEntry(std::move(entry));
       return;
     }
-
-    if (old_page_back_forward_cache_metrics)
-      old_page_back_forward_cache_metrics->MarkNotRestoredWithReason(can_store);
   }
 
   // Create a replacement proxy for the old RenderFrameHost when we're switching
