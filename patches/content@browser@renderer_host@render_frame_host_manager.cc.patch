diff --git a/content/browser/renderer_host/render_frame_host_manager.cc b/content/browser/renderer_host/render_frame_host_manager.cc
index af2a0a2e5559..1f18f5b842c9 100644
--- a/content/browser/renderer_host/render_frame_host_manager.cc
+++ b/content/browser/renderer_host/render_frame_host_manager.cc
@@ -500,28 +500,6 @@ void RenderFrameHostManager::UnloadOldFrame(
   // RenderFrameHost should not be trying to commit a navigation.
   old_render_frame_host->ResetNavigationRequests();
 
-  NavigationEntryImpl* last_committed_entry =
-      delegate_->GetControllerForRenderManager().GetLastCommittedEntry();
-  BackForwardCacheMetrics* old_page_back_forward_cache_metrics =
-      (!old_render_frame_host->GetParent() && last_committed_entry)
-          ? last_committed_entry->back_forward_cache_metrics()
-          : nullptr;
-
-  // Record the metrics about the state of the old main frame at the moment when
-  // we navigate away from it as it matters for whether the page is eligible for
-  // being put into back-forward cache.
-  //
-  // This covers the cross-process navigation case and the same-process case is
-  // handled in RenderFrameHostImpl::CommitNavigation, so the subframe state
-  // can be captured before the frame navigates away.
-  //
-  // TODO(altimin, crbug.com/933147): Remove this logic after we are done with
-  // implementing back-forward cache.
-  if (old_page_back_forward_cache_metrics) {
-    old_page_back_forward_cache_metrics->RecordFeatureUsage(
-        old_render_frame_host.get());
-  }
-
   // BackForwardCache:
   //
   // If the old RenderFrameHost can be stored in the BackForwardCache, return
@@ -570,9 +548,6 @@ void RenderFrameHostManager::UnloadOldFrame(
       back_forward_cache.StoreEntry(std::move(entry));
       return;
     }
-
-    if (old_page_back_forward_cache_metrics)
-      old_page_back_forward_cache_metrics->MarkNotRestoredWithReason(can_store);
   }
 
   // Create a replacement proxy for the old RenderFrameHost when we're switching
@@ -1487,13 +1462,6 @@ RenderFrameHostManager::ShouldProactivelySwapBrowsingInstance(
       return ShouldSwapBrowsingInstance::kYes_CrossSiteProactiveSwap;
     }
   } else {
-    // As CanPotentiallyStorePageLater is used instead of CanStorePageNow, non-
-    // sticky reasons are not recorded here. This is intentional because it is
-    // impossible to get correct non-sticky reasons at this timing.
-    BackForwardCacheMetrics* back_forward_cache_metrics =
-        render_frame_host_->GetBackForwardCacheMetrics();
-    if (back_forward_cache_metrics)
-      back_forward_cache_metrics->MarkNotRestoredWithReason(can_store);
     return ShouldSwapBrowsingInstance::kNo_NotNeededForBackForwardCache;
   }
 }
