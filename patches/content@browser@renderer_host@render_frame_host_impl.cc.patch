diff --git a/content/browser/renderer_host/render_frame_host_impl.cc b/content/browser/renderer_host/render_frame_host_impl.cc
index 04ccff2b3586..7518002afd53 100644
--- a/content/browser/renderer_host/render_frame_host_impl.cc
+++ b/content/browser/renderer_host/render_frame_host_impl.cc
@@ -199,8 +199,6 @@
 #include "services/device/public/mojom/sensor_provider.mojom.h"
 #include "services/device/public/mojom/wake_lock.mojom.h"
 #include "services/device/public/mojom/wake_lock_context.mojom.h"
-#include "services/metrics/public/cpp/ukm_builders.h"
-#include "services/metrics/public/cpp/ukm_source_id.h"
 #include "services/network/public/cpp/features.h"
 #include "services/network/public/cpp/is_potentially_trustworthy.h"
 #include "services/network/public/cpp/trust_token_operation_authorization.h"
@@ -1593,7 +1591,6 @@ bool RenderFrameHostImpl::CreateNetworkServiceDefaultFactory(
 
   return CreateNetworkServiceDefaultFactoryAndObserve(
       CreateURLLoaderFactoryParamsForMainWorld(navigation_request),
-      ukm::SourceIdObj::FromInt64(GetPageUkmSourceId()),
       std::move(default_factory_receiver));
 }
 
@@ -1668,7 +1665,6 @@ RenderFrameHostImpl::CreateURLLoaderFactoriesForIsolatedWorlds(
     mojo::PendingRemote<network::mojom::URLLoaderFactory> factory_remote;
     CreateNetworkServiceDefaultFactoryAndObserve(
         std::move(factory_params),
-        ukm::kInvalidSourceIdObj, /* isolated from page */
         factory_remote.InitWithNewPipeAndPassReceiver());
     result[isolated_world_origin] = std::move(factory_remote);
   }
@@ -3299,10 +3295,6 @@ void RenderFrameHostImpl::ProcessBeforeUnloadCompletedFromFrame(
         (renderer_before_unload_end_time - renderer_before_unload_start_time);
     UMA_HISTOGRAM_TIMES("Navigation.OnBeforeUnloadOverheadTime",
                         on_before_unload_overhead_time);
-
-    frame_tree_node_->navigator().LogBeforeUnloadTime(
-        renderer_before_unload_start_time, renderer_before_unload_end_time,
-        send_before_unload_start_time_);
   }
 
   // Resets beforeunload waiting state.
@@ -3730,15 +3722,6 @@ void RenderFrameHostImpl::ReportNoBinderForInterface(const std::string& error) {
   broker_receiver_.ReportBadMessage(error + " for the frame/document scope");
 }
 
-ukm::SourceId RenderFrameHostImpl::GetPageUkmSourceId() {
-  int64_t navigation_id =
-      GetMainFrame()->last_committed_cross_document_navigation_id_;
-  if (navigation_id == -1)
-    return ukm::kInvalidSourceId;
-  return ukm::ConvertToSourceId(navigation_id,
-                                ukm::SourceIdType::NAVIGATION_ID);
-}
-
 BrowserContext* RenderFrameHostImpl::GetBrowserContext() {
   return GetProcess()->GetBrowserContext();
 }
@@ -3951,10 +3934,6 @@ void RenderFrameHostImpl::UpdateSubresourceLoaderFactories() {
     bypass_redirect_checks = CreateNetworkServiceDefaultFactoryAndObserve(
         CreateURLLoaderFactoryParamsForMainWorld(
             latest_nav_request_still_committing),
-        ukm::SourceIdObj::FromInt64(
-            latest_nav_request_still_committing
-                ? latest_nav_request_still_committing->GetNextPageUkmSourceId()
-                : GetPageUkmSourceId()),
         default_factory_remote.InitWithNewPipeAndPassReceiver());
   }
 
@@ -4511,19 +4490,9 @@ void RenderFrameHostImpl::EvictFromBackForwardCacheWithReasons(
     DCHECK_EQ(top_document->IsInBackForwardCache(), in_back_forward_cache);
   }
 
-  // TODO(hajimehoshi): Record the 'race condition' by JavaScript execution when
-  // |in_back_forward_cache| is false.
-  BackForwardCacheMetrics* metrics = top_document->GetBackForwardCacheMetrics();
-  if (in_back_forward_cache && metrics)
-    metrics->MarkNotRestoredWithReason(can_store);
-
   if (!in_back_forward_cache) {
     TRACE_EVENT0("navigation", "BackForwardCache_EvictAfterDocumentRestored");
 
-    BackForwardCacheMetrics::RecordEvictedAfterDocumentRestored(
-        BackForwardCacheMetrics::EvictedAfterDocumentRestoredReason::
-            kByJavaScript);
-
     // A document is evicted from the BackForwardCache, but it has already been
     // restored. The current document should be reloaded, because it is not
     // salvageable.
@@ -5083,9 +5052,6 @@ RenderFrameHostImpl::CreateCrossOriginPrefetchLoaderFactoryBundle() {
   // it.
   bypass_redirect_checks = CreateNetworkServiceDefaultFactoryAndObserve(
       std::move(factory_params),
-      // This is for renderer prefetches, so it's associated with this page, not
-      // pending navigation.
-      ukm::SourceIdObj::FromInt64(GetPageUkmSourceId()),
       pending_default_factory.InitWithNewPipeAndPassReceiver());
 
   return std::make_unique<blink::PendingURLLoaderFactoryBundle>(
@@ -5664,11 +5630,6 @@ void RenderFrameHostImpl::HandleAXLocationChanges(
   }
 }
 
-media::MediaMetricsProvider::RecordAggregateWatchTimeCallback
-RenderFrameHostImpl::GetRecordAggregateWatchTimeCallback() {
-  return delegate_->GetRecordAggregateWatchTimeCallback();
-}
-
 void RenderFrameHostImpl::ResetWaitingState() {
   // We don't allow resetting waiting state when the RenderFrameHost is either
   // in BackForwardCache or in pending deletion state, as we don't allow
@@ -6287,8 +6248,6 @@ void RenderFrameHostImpl::CommitNavigation(
   }
   // This needs to ask |navigation_request| for the UKM ID since the commit is
   // in progress but not yet done.
-  ukm::SourceIdObj next_page_ukm_source_id =
-      ukm::SourceIdObj::FromInt64(navigation_request->GetNextPageUkmSourceId());
   std::unique_ptr<blink::PendingURLLoaderFactoryBundle>
       subresource_loader_factories;
   if ((!is_same_document || is_first_navigation) && !is_srcdoc) {
@@ -6316,7 +6275,7 @@ void RenderFrameHostImpl::CommitNavigation(
               browser_context, this, GetProcess()->GetID(),
               ContentBrowserClient::URLLoaderFactoryType::kDocumentSubResource,
               main_world_origin_for_url_loader_factory,
-              base::nullopt /* navigation_id */, next_page_ukm_source_id,
+              base::nullopt /* navigation_id */,
               &appcache_proxied_receiver, nullptr /* header_client */,
               nullptr /* bypass_redirect_checks */,
               nullptr /* disable_secure_dns */, nullptr /* factory_override */);
@@ -6347,7 +6306,7 @@ void RenderFrameHostImpl::CommitNavigation(
           browser_context, this, GetProcess()->GetID(),
           ContentBrowserClient::URLLoaderFactoryType::kDocumentSubResource,
           main_world_origin_for_url_loader_factory,
-          base::nullopt /* navigation_id */, next_page_ukm_source_id,
+          base::nullopt /* navigation_id */,
           &factory_receiver, nullptr /* header_client */,
           nullptr /* bypass_redirect_checks */,
           nullptr /* disable_secure_dns */, nullptr /* factory_override */);
@@ -6386,7 +6345,6 @@ void RenderFrameHostImpl::CommitNavigation(
       bool bypass_redirect_checks =
           CreateNetworkServiceDefaultFactoryAndObserve(
               CreateURLLoaderFactoryParamsForMainWorld(navigation_request),
-              next_page_ukm_source_id,
               pending_default_factory.InitWithNewPipeAndPassReceiver());
       subresource_loader_factories->set_bypass_redirect_checks(
           bypass_redirect_checks);
@@ -6477,7 +6435,7 @@ void RenderFrameHostImpl::CommitNavigation(
       mojo::PendingReceiver<network::mojom::URLLoaderFactory> factory_receiver =
           pending_factory_proxy.InitWithNewPipeAndPassReceiver();
       WillCreateURLLoaderFactory(main_world_origin_for_url_loader_factory,
-                                 &factory_receiver, next_page_ukm_source_id);
+                                 &factory_receiver);
       mojo::Remote<network::mojom::URLLoaderFactory> remote(
           std::move(factory.second));
       remote->Clone(std::move(factory_receiver));
@@ -6562,32 +6520,6 @@ void RenderFrameHostImpl::CommitNavigation(
     mojom::NavigationClient* navigation_client =
         navigation_request->GetCommitNavigationClient();
 
-    // Record the metrics about the state of the old main frame at the moment
-    // when we navigate away from it as it matters for whether the page
-    // is eligible for being put into back-forward cache.
-    //
-    // Ideally we would do this when we are just about to swap out the old
-    // render frame and swap in the new one, but we can't do this for
-    // same-process navigations yet as we are reusing the RenderFrameHost and
-    // as the local frame navigates it overrides the values that we are
-    // interested in. The cross-process navigation case is handled in
-    // RenderFrameHostManager::UnloadOldFrame.
-    //
-    // Here we are recording the metrics for same-process navigations at the
-    // point just before the navigation commits.
-    // TODO(altimin, crbug.com/933147): Remove this logic after we are done with
-    // implementing back-forward cache.
-    if (!GetParent() && frame_tree_node_->current_frame_host() == this) {
-      if (NavigationEntryImpl* last_committed_entry =
-              NavigationEntryImpl::FromNavigationEntry(
-                  frame_tree()->controller()->GetLastCommittedEntry())) {
-        if (last_committed_entry->back_forward_cache_metrics()) {
-          last_committed_entry->back_forward_cache_metrics()
-              ->RecordFeatureUsage(this);
-        }
-      }
-    }
-
     // about:srcdoc "inherits" loaders from its parent in the renderer process,
     // There are no need to provide new ones here.
     // TODO(arthursonzogni): What about about:blank URLs?
@@ -6668,7 +6600,6 @@ void RenderFrameHostImpl::FailedNavigation(
   mojo::PendingRemote<network::mojom::URLLoaderFactory> default_factory_remote;
   bool bypass_redirect_checks = CreateNetworkServiceDefaultFactoryAndObserve(
       CreateURLLoaderFactoryParamsForMainWorld(navigation_request),
-      ukm::kInvalidSourceIdObj,
       default_factory_remote.InitWithNewPipeAndPassReceiver());
   subresource_loader_factories =
       std::make_unique<blink::PendingURLLoaderFactoryBundle>(
@@ -6685,9 +6616,6 @@ void RenderFrameHostImpl::FailedNavigation(
       commit_params.Clone(), has_stale_copy_in_cache, error_code,
       error_page_content, std::move(subresource_loader_factories));
 
-  // TODO(crbug/1129537): support UKM source creation for failed navigations
-  // too.
-
   // An error page is expected to commit, hence why is_loading_ is set to true.
   is_loading_ = true;
   dom_content_loaded_ = false;
@@ -7341,11 +7269,10 @@ RenderFrameHostImpl::CreateURLLoaderFactoryParamsForMainWorld(
 
 bool RenderFrameHostImpl::CreateNetworkServiceDefaultFactoryAndObserve(
     network::mojom::URLLoaderFactoryParamsPtr params,
-    ukm::SourceIdObj ukm_source_id,
     mojo::PendingReceiver<network::mojom::URLLoaderFactory>
         default_factory_receiver) {
   bool bypass_redirect_checks = CreateNetworkServiceDefaultFactoryInternal(
-      std::move(params), ukm_source_id, std::move(default_factory_receiver));
+      std::move(params), std::move(default_factory_receiver));
 
   // Add a disconnect handler when Network Service is running
   // out-of-process.
@@ -7378,7 +7305,6 @@ bool RenderFrameHostImpl::CreateNetworkServiceDefaultFactoryAndObserve(
 
 bool RenderFrameHostImpl::CreateNetworkServiceDefaultFactoryInternal(
     network::mojom::URLLoaderFactoryParamsPtr params,
-    ukm::SourceIdObj ukm_source_id,
     mojo::PendingReceiver<network::mojom::URLLoaderFactory>
         default_factory_receiver) {
   DCHECK(params->request_initiator_origin_lock.has_value());
@@ -7387,7 +7313,7 @@ bool RenderFrameHostImpl::CreateNetworkServiceDefaultFactoryInternal(
 
   bool bypass_redirect_checks = false;
   WillCreateURLLoaderFactory(
-      request_initiator, &default_factory_receiver, ukm_source_id,
+      request_initiator, &default_factory_receiver,
       &params->header_client, &bypass_redirect_checks,
       &params->disable_secure_dns, &params->factory_override);
 
@@ -7400,7 +7326,6 @@ bool RenderFrameHostImpl::CreateNetworkServiceDefaultFactoryInternal(
 void RenderFrameHostImpl::WillCreateURLLoaderFactory(
     const url::Origin& request_initiator,
     mojo::PendingReceiver<network::mojom::URLLoaderFactory>* factory_receiver,
-    ukm::SourceIdObj ukm_source_id,
     mojo::PendingRemote<network::mojom::TrustedURLLoaderHeaderClient>*
         header_client,
     bool* bypass_redirect_checks,
@@ -7409,7 +7334,7 @@ void RenderFrameHostImpl::WillCreateURLLoaderFactory(
   GetContentClient()->browser()->WillCreateURLLoaderFactory(
       GetBrowserContext(), this, GetProcess()->GetID(),
       ContentBrowserClient::URLLoaderFactoryType::kDocumentSubResource,
-      request_initiator, base::nullopt /* navigation_id */, ukm_source_id,
+      request_initiator, base::nullopt /* navigation_id */,
       factory_receiver, header_client, bypass_redirect_checks,
       disable_secure_dns, factory_override);
 
@@ -7675,58 +7600,6 @@ void RenderFrameHostImpl::BindMediaInterfaceFactoryReceiver(
   media_interface_proxy_->Bind(std::move(receiver));
 }
 
-void RenderFrameHostImpl::BindMediaMetricsProviderReceiver(
-    mojo::PendingReceiver<media::mojom::MediaMetricsProvider> receiver) {
-  // Only save decode stats when BrowserContext provides a VideoPerfHistory.
-  // Off-the-record contexts will internally use an ephemeral history DB.
-  media::VideoDecodePerfHistory::SaveCallback save_stats_cb;
-  if (GetSiteInstance()->GetBrowserContext()->GetVideoDecodePerfHistory()) {
-    save_stats_cb = GetSiteInstance()
-                        ->GetBrowserContext()
-                        ->GetVideoDecodePerfHistory()
-                        ->GetSaveCallback();
-  }
-
-  media::MediaMetricsProvider::Create(
-      GetProcess()->GetBrowserContext()->IsOffTheRecord()
-          ? media::MediaMetricsProvider::BrowsingMode::kIncognito
-          : media::MediaMetricsProvider::BrowsingMode::kNormal,
-      frame_tree_node_->IsMainFrame()
-          ? media::MediaMetricsProvider::FrameStatus::kTopFrame
-          : media::MediaMetricsProvider::FrameStatus::kNotTopFrame,
-      base::BindRepeating(
-          &RenderFrameHostDelegate::
-              GetUkmSourceIdForLastCommittedSourceIncludingSameDocument,
-          // This callback is only executed when Create() is called, during
-          // which the lifetime of the |delegate_| is guaranteed.
-          base::Unretained(delegate_)),
-      base::BindRepeating(
-          [](RenderFrameHostImpl* frame) {
-            return ::media::learning::FeatureValue(
-                frame->GetLastCommittedOrigin().host());
-          },
-          // Same as above.
-          base::Unretained(this)),
-      std::move(save_stats_cb),
-      base::BindRepeating(
-          [](base::WeakPtr<RenderFrameHostImpl> frame)
-              -> media::learning::LearningSession* {
-            if (!base::FeatureList::IsEnabled(media::kMediaLearningFramework) ||
-                !frame) {
-              return nullptr;
-            }
-
-            return frame->GetProcess()
-                ->GetBrowserContext()
-                ->GetLearningSession();
-          },
-          weak_ptr_factory_.GetWeakPtr()),
-      base::BindRepeating(
-          &RenderFrameHostImpl::GetRecordAggregateWatchTimeCallback,
-          base::Unretained(this)),
-      std::move(receiver));
-}
-
 #if BUILDFLAG(ENABLE_MEDIA_REMOTING)
 void RenderFrameHostImpl::BindMediaRemoterFactoryReceiver(
     mojo::PendingReceiver<media::mojom::RemoterFactory> receiver) {
@@ -8628,20 +8501,6 @@ bool RenderFrameHostImpl::DidCommitNavigationInternal(
     // Resets when navigating to a new document. This is needed because
     // RenderFrameHost might be reused for a new document
     document_used_web_otp_ = false;
-
-    // Get the UKM source id sent to the renderer.
-    const ukm::SourceId document_ukm_source_id =
-        navigation_request->commit_params().document_ukm_source_id;
-
-    ukm::UkmRecorder* ukm_recorder = ukm::UkmRecorder::Get();
-
-    // Associate the blink::Document source id to the URL. Only URLs on main
-    // frames can be recorded.
-    if (is_main_frame() && document_ukm_source_id != ukm::kInvalidSourceId)
-      ukm_recorder->UpdateSourceURL(document_ukm_source_id, params->url);
-
-    RecordDocumentCreatedUkmEvent(params->origin, document_ukm_source_id,
-                                  ukm_recorder);
   }
 
   // If we still have a PeakGpuMemoryTracker, then the loading it was observing
@@ -9487,14 +9346,6 @@ void RenderFrameHostImpl::EnableMojoJsBindings() {
   GetFrameBindingsControl()->EnableMojoJsBindings();
 }
 
-BackForwardCacheMetrics* RenderFrameHostImpl::GetBackForwardCacheMetrics() {
-  NavigationEntryImpl* navigation_entry =
-      frame_tree()->controller()->GetEntryWithUniqueID(nav_entry_id());
-  if (!navigation_entry)
-    return nullptr;
-  return navigation_entry->back_forward_cache_metrics();
-}
-
 bool RenderFrameHostImpl::IsBackForwardCacheDisabled() const {
   return back_forward_cache_disabled_reasons_.size();
 }
@@ -9660,29 +9511,6 @@ void RenderFrameHostImpl::SetLifecycleState(LifecycleState state) {
   delegate_->RenderFrameHostStateChanged(this, old_state, lifecycle_state_);
 }
 
-void RenderFrameHostImpl::RecordDocumentCreatedUkmEvent(
-    const url::Origin& origin,
-    const ukm::SourceId document_ukm_source_id,
-    ukm::UkmRecorder* ukm_recorder) {
-  DCHECK(ukm_recorder);
-  if (document_ukm_source_id == ukm::kInvalidSourceId)
-    return;
-
-  // Compares the subframe origin with the main frame origin. In the case of
-  // nested subframes such as A(B(A)), the bottom-most frame A is expected to
-  // have |is_cross_origin_frame| set to false, even though this frame is cross-
-  // origin from its parent frame B. This value is only used in manual analysis.
-  bool is_cross_origin_frame =
-      !is_main_frame() &&
-      !GetMainFrame()->GetLastCommittedOrigin().IsSameOriginWith(origin);
-
-  ukm::builders::DocumentCreated(document_ukm_source_id)
-      .SetNavigationSourceId(GetPageUkmSourceId())
-      .SetIsMainFrame(is_main_frame())
-      .SetIsCrossOriginFrame(is_cross_origin_frame)
-      .Record(ukm_recorder);
-}
-
 void RenderFrameHostImpl::BindReportingObserver(
     mojo::PendingReceiver<blink::mojom::ReportingObserver> receiver) {
   GetAssociatedLocalFrame()->BindReportingObserver(std::move(receiver));
