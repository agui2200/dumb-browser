diff --git a/content/browser/renderer_host/render_frame_host_impl.cc b/content/browser/renderer_host/render_frame_host_impl.cc
index dac922a6bd56..94a12933bde4 100644
--- a/content/browser/renderer_host/render_frame_host_impl.cc
+++ b/content/browser/renderer_host/render_frame_host_impl.cc
@@ -74,8 +74,6 @@
 #include "content/browser/media/media_interface_proxy.h"
 #include "content/browser/media/webaudio/audio_context_manager_impl.h"
 #include "content/browser/navigation_subresource_loader_params.h"
-#include "content/browser/net/cross_origin_embedder_policy_reporter.h"
-#include "content/browser/net/cross_origin_opener_policy_reporter.h"
 #include "content/browser/payments/payment_app_context_impl.h"
 #include "content/browser/permissions/permission_controller_impl.h"
 #include "content/browser/permissions/permission_service_context.h"
@@ -1163,13 +1161,6 @@ RenderFrameHostImpl::RenderFrameHostImpl(
   DCHECK_EQ(setup_local_render_widget_host, is_local_root());
   ResetFeaturePolicy();
 
-  // New RenderFrameHostImpl are put in their own virtual browsing context
-  // group. Then, they can inherit from:
-  // 1) Their opener in RenderFrameHostImpl::CreateNewWindow().
-  // 2) Their navigation in RenderFrameHostImpl::DidCommitNavigationInternal().
-  virtual_browsing_context_group_ =
-      CrossOriginOpenerPolicyReporter::NextVirtualBrowsingContextGroup();
-
   // IdleManager should be unique per RenderFrame to provide proper isolation
   // of overrides.
   idle_manager_ =
@@ -1750,7 +1741,7 @@ RenderFrameHostImpl::CreateURLLoaderFactoriesForIsolatedWorlds(
       network::mojom::TrustTokenRedemptionPolicy::kForbid;
   ExtractFactoryParamsFromNavigationRequestOrLastCommittedNavigation(
       navigation_request, &main_world_origin, &isolation_info,
-      &client_security_state, nullptr /* coep_reporter_remote */,
+      &client_security_state,
       &trust_token_redemption_policy);
 
   blink::PendingURLLoaderFactoryBundle::OriginMap result;
@@ -5384,11 +5375,6 @@ void RenderFrameHostImpl::CreateNewWindow(
   if (!params->opener_suppressed)
     popup_coep = cross_origin_embedder_policy();
 
-  int popup_virtual_browsing_context_group =
-      params->opener_suppressed
-          ? CrossOriginOpenerPolicyReporter::NextVirtualBrowsingContextGroup()
-          : top_level_opener->virtual_browsing_context_group();
-
   // If the opener is suppressed or script access is disallowed, we should
   // open the window in a new BrowsingInstance, and thus a new process. That
   // means the current renderer process will not be able to route messages to
@@ -5426,19 +5412,6 @@ void RenderFrameHostImpl::CreateNewWindow(
   main_frame->SetOriginDependentStateOfNewFrame(GetLastCommittedOrigin());
   main_frame->cross_origin_opener_policy_ = popup_coop;
   main_frame->cross_origin_embedder_policy_ = popup_coep;
-  main_frame->virtual_browsing_context_group_ =
-      popup_virtual_browsing_context_group;
-
-  // If inheriting coop (checking this via |opener_suppressed|) and the original
-  // coop page has a reporter we make sure the the newly created popup also has
-  // a reporter.
-  if (!params->opener_suppressed && GetMainFrame()->coop_reporter()) {
-    main_frame->set_coop_reporter(
-        std::make_unique<CrossOriginOpenerPolicyReporter>(
-            GetProcess()->GetStoragePartition(), GetLastCommittedURL(),
-            params->referrer->url, popup_coop,
-            isolation_info_.network_isolation_key()));
-  }
 
   mojo::PendingAssociatedRemote<mojom::Frame> pending_frame_remote;
   mojo::PendingAssociatedReceiver<mojom::Frame> pending_frame_receiver =
@@ -5832,11 +5805,6 @@ void RenderFrameHostImpl::HandleAXLocationChanges(
   delegate_->AccessibilityLocationChangesReceived(details);
 }
 
-media::MediaMetricsProvider::RecordAggregateWatchTimeCallback
-RenderFrameHostImpl::GetRecordAggregateWatchTimeCallback() {
-  return delegate_->GetRecordAggregateWatchTimeCallback();
-}
-
 void RenderFrameHostImpl::ResetWaitingState() {
   // We don't allow resetting waiting state when the RenderFrameHost is either
   // in BackForwardCache or in pending deletion state, as we don't allow
@@ -7464,37 +7432,29 @@ void RenderFrameHostImpl::
         url::Origin* out_main_world_origin,
         net::IsolationInfo* out_isolation_info,
         network::mojom::ClientSecurityStatePtr* out_client_security_state,
-        mojo::PendingRemote<network::mojom::CrossOriginEmbedderPolicyReporter>*
-            coep_reporter_pending_remote,
         network::mojom::TrustTokenRedemptionPolicy*
             out_trust_token_redemption_policy) {
   // |navigation_request| is optional.
   DCHECK(out_main_world_origin);
   DCHECK(out_client_security_state);
-  // |coep_reporter_receiver| is optional.
   DCHECK(out_trust_token_redemption_policy);
 
-  CrossOriginEmbedderPolicyReporter* coep_reporter = nullptr;
-
   if (navigation_request) {
     // Return values based on the |navigation_request|.
     *out_main_world_origin = navigation_request->GetOriginForURLLoaderFactory();
     *out_client_security_state = navigation_request->BuildClientSecurityState();
 
     // TODO(lukasza): Consider pushing the ok-vs-error differentiation into
-    // NavigationRequest methods (e.g. into |isolation_info_for_subresources|
-    // and/or |coep_reporter| methods).
+    // NavigationRequest methods (e.g. into |isolation_info_for_subresources|).
     if (navigation_request->GetNetErrorCode() == net::OK) {
       *out_isolation_info =
           navigation_request->isolation_info_for_subresources();
-      coep_reporter = navigation_request->coep_reporter();
       *out_trust_token_redemption_policy =
           DetermineWhetherToForbidTrustTokenRedemption(
               GetParent(), navigation_request->commit_params(),
               *out_main_world_origin);
     } else {
       *out_isolation_info = net::IsolationInfo::CreateTransient();
-      coep_reporter = nullptr;
       *out_trust_token_redemption_policy =
           network::mojom::TrustTokenRedemptionPolicy::kForbid;
     }
@@ -7503,15 +7463,9 @@ void RenderFrameHostImpl::
     *out_main_world_origin = last_committed_origin_;
     *out_isolation_info = isolation_info_;
     *out_client_security_state = BuildClientSecurityState();
-    coep_reporter = coep_reporter_.get();
     *out_trust_token_redemption_policy =
         DetermineAfterCommitWhetherToForbidTrustTokenRedemption(this);
   }
-
-  if (coep_reporter && coep_reporter_pending_remote) {
-    coep_reporter->Clone(
-        coep_reporter_pending_remote->InitWithNewPipeAndPassReceiver());
-  }
 }
 
 network::mojom::URLLoaderFactoryParamsPtr
@@ -7521,18 +7475,16 @@ RenderFrameHostImpl::CreateURLLoaderFactoryParamsForMainWorld(
   url::Origin main_world_origin;
   net::IsolationInfo isolation_info;
   network::mojom::ClientSecurityStatePtr client_security_state;
-  mojo::PendingRemote<network::mojom::CrossOriginEmbedderPolicyReporter>
-      coep_reporter_remote;
   network::mojom::TrustTokenRedemptionPolicy trust_token_redemption_policy =
       network::mojom::TrustTokenRedemptionPolicy::kForbid;
   ExtractFactoryParamsFromNavigationRequestOrLastCommittedNavigation(
       navigation_request, &main_world_origin, &isolation_info,
-      &client_security_state, &coep_reporter_remote,
+      &client_security_state,
       &trust_token_redemption_policy);
 
   return URLLoaderFactoryParamsHelper::CreateForFrame(
       this, main_world_origin, isolation_info, std::move(client_security_state),
-      std::move(coep_reporter_remote), GetProcess(),
+      GetProcess(),
       trust_token_redemption_policy, debug_tag);
 }
 
@@ -7892,58 +7844,6 @@ void RenderFrameHostImpl::BindMediaInterfaceFactoryReceiver(
   media_interface_proxy_->Bind(std::move(receiver));
 }
 
-void RenderFrameHostImpl::BindMediaMetricsProviderReceiver(
-    mojo::PendingReceiver<media::mojom::MediaMetricsProvider> receiver) {
-  // Only save decode stats when BrowserContext provides a VideoPerfHistory.
-  // Off-the-record contexts will internally use an ephemeral history DB.
-  media::VideoDecodePerfHistory::SaveCallback save_stats_cb;
-  if (GetSiteInstance()->GetBrowserContext()->GetVideoDecodePerfHistory()) {
-    save_stats_cb = GetSiteInstance()
-                        ->GetBrowserContext()
-                        ->GetVideoDecodePerfHistory()
-                        ->GetSaveCallback();
-  }
-
-  media::MediaMetricsProvider::Create(
-      GetProcess()->GetBrowserContext()->IsOffTheRecord()
-          ? media::MediaMetricsProvider::BrowsingMode::kIncognito
-          : media::MediaMetricsProvider::BrowsingMode::kNormal,
-      frame_tree_node_->IsMainFrame()
-          ? media::MediaMetricsProvider::FrameStatus::kTopFrame
-          : media::MediaMetricsProvider::FrameStatus::kNotTopFrame,
-      base::BindRepeating(
-          &RenderFrameHostDelegate::
-              GetUkmSourceIdForLastCommittedSourceIncludingSameDocument,
-          // This callback is only executed when Create() is called, during
-          // which the lifetime of the |delegate_| is guaranteed.
-          base::Unretained(delegate_)),
-      base::BindRepeating(
-          [](RenderFrameHostImpl* frame) {
-            return ::media::learning::FeatureValue(
-                frame->GetLastCommittedOrigin().host());
-          },
-          // Same as above.
-          base::Unretained(this)),
-      std::move(save_stats_cb),
-      base::BindRepeating(
-          [](base::WeakPtr<RenderFrameHostImpl> frame)
-              -> media::learning::LearningSession* {
-            if (!base::FeatureList::IsEnabled(media::kMediaLearningFramework) ||
-                !frame) {
-              return nullptr;
-            }
-
-            return frame->GetProcess()
-                ->GetBrowserContext()
-                ->GetLearningSession();
-          },
-          weak_ptr_factory_.GetWeakPtr()),
-      base::BindRepeating(
-          &RenderFrameHostImpl::GetRecordAggregateWatchTimeCallback,
-          base::Unretained(this)),
-      std::move(receiver));
-}
-
 #if BUILDFLAG(ENABLE_MEDIA_REMOTING)
 void RenderFrameHostImpl::BindMediaRemoterFactoryReceiver(
     mojo::PendingReceiver<media::mojom::RemoterFactory> receiver) {
@@ -7986,12 +7886,6 @@ void RenderFrameHostImpl::CreateDedicatedWorkerHostFactory(
   // Allocate the worker in the same process as the creator.
   int worker_process_id = GetProcess()->GetID();
 
-  mojo::PendingRemote<network::mojom::CrossOriginEmbedderPolicyReporter>
-      coep_reporter;
-  auto coep_reporter_endpoint = coep_reporter.InitWithNewPipeAndPassReceiver();
-  if (coep_reporter_)
-    coep_reporter_->Clone(std::move(coep_reporter_endpoint));
-
   // When a dedicated worker is created from the frame script, the frame is both
   // the creator and the ancestor.
   mojo::MakeSelfOwnedReceiver(
@@ -8001,7 +7895,7 @@ void RenderFrameHostImpl::CreateDedicatedWorkerHostFactory(
           /*creator_worker_token=*/base::nullopt,
           /*ancestor_render_frame_host_id=*/GetGlobalFrameRoutingId(),
           last_committed_origin_, isolation_info_,
-          cross_origin_embedder_policy_, std::move(coep_reporter)),
+          cross_origin_embedder_policy_),
       std::move(receiver));
 }
 
@@ -8095,14 +7989,7 @@ void RenderFrameHostImpl::GetSensorProvider(
 
 void RenderFrameHostImpl::BindCacheStorage(
     mojo::PendingReceiver<blink::mojom::CacheStorage> receiver) {
-  mojo::PendingRemote<network::mojom::CrossOriginEmbedderPolicyReporter>
-      coep_reporter_remote;
-  if (coep_reporter_) {
-    coep_reporter_->Clone(
-        coep_reporter_remote.InitWithNewPipeAndPassReceiver());
-  }
   GetProcess()->BindCacheStorage(cross_origin_embedder_policy_,
-                                 std::move(coep_reporter_remote),
                                  GetLastCommittedOrigin(), std::move(receiver));
 }
 
@@ -8357,16 +8244,6 @@ RenderFrameHostImpl::CreateNavigationRequestForCommit(
   net::IsolationInfo isolation_info = ComputeIsolationInfoInternal(
       origin, net::IsolationInfo::RequestType::kOther);
 
-  std::unique_ptr<CrossOriginEmbedderPolicyReporter> coep_reporter;
-  // We don't switch the COEP reporter on same-document navigations, so create
-  // one only for cross-document navigations.
-  if (!is_same_document) {
-    coep_reporter = std::make_unique<CrossOriginEmbedderPolicyReporter>(
-        GetProcess()->GetStoragePartition(), url,
-        cross_origin_embedder_policy_.reporting_endpoint,
-        cross_origin_embedder_policy_.report_only_reporting_endpoint,
-        isolation_info.network_isolation_key());
-  }
   std::unique_ptr<WebBundleNavigationInfo> web_bundle_navigation_info;
   if (is_same_document && web_bundle_handle_ &&
       web_bundle_handle_->navigation_info()) {
@@ -8399,7 +8276,7 @@ RenderFrameHostImpl::CreateNavigationRequestForCommit(
       frame_tree_node_, this, is_same_document, url, origin, isolation_info,
       std::move(referrer), transition, should_replace_current_entry, method,
       gesture, is_overriding_user_agent, redirects, original_request_url,
-      page_state, std::move(coep_reporter),
+      page_state,
       std::move(web_bundle_navigation_info), http_status_code);
 }
 
@@ -9000,9 +8877,6 @@ void RenderFrameHostImpl::DidCommitNewDocument(
 
   TakeNewDocumentPropertiesFromNavigation(navigation_request);
 
-  CrossOriginOpenerPolicyReporter::InstallAccessMonitorsIfNeeded(
-      frame_tree_node_);
-
   // Reset the salt so that media device IDs are reset for the new document
   // if necessary.
   media_device_id_salt_base_ = BrowserContext::CreateRandomMediaDeviceIDSalt();
@@ -9020,28 +8894,10 @@ void RenderFrameHostImpl::TakeNewDocumentPropertiesFromNavigation(
   cross_origin_opener_policy_ =
       navigation_request->coop_status().current_coop();
 
-  coop_reporter_ = navigation_request->coop_status().TakeCoopReporter();
-  virtual_browsing_context_group_ =
-      navigation_request->coop_status().virtual_browsing_context_group();
-
   // Store the required CSP (it will be used by the AncestorThrottle if
   // this frame embeds a subframe when that subframe navigates).
   required_csp_ = navigation_request->TakeRequiredCSP();
 
-  coep_reporter_ = navigation_request->TakeCoepReporter();
-  if (coep_reporter_) {
-    mojo::PendingRemote<blink::mojom::ReportingObserver> remote;
-    mojo::PendingReceiver<blink::mojom::ReportingObserver> receiver =
-        remote.InitWithNewPipeAndPassReceiver();
-    coep_reporter_->BindObserver(std::move(remote));
-    // As some tests override the associated frame after commit, do not
-    // call GetAssociatedLocalFrame now.
-    base::ThreadTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE,
-        base::BindOnce(&RenderFrameHostImpl::BindReportingObserver,
-                       weak_ptr_factory_.GetWeakPtr(), std::move(receiver)));
-  }
-
   // Set the state whether this navigation is to an MHTML document, since there
   // are certain security checks that we cannot apply to subframes in MHTML
   // documents. Do not trust renderer data when determining that, rather use
@@ -10420,11 +10276,6 @@ void RenderFrameHostImpl::RecordDocumentCreatedUkmEvent(
       .Record(ukm_recorder);
 }
 
-void RenderFrameHostImpl::BindReportingObserver(
-    mojo::PendingReceiver<blink::mojom::ReportingObserver> receiver) {
-  GetAssociatedLocalFrame()->BindReportingObserver(std::move(receiver));
-}
-
 mojo::PendingRemote<network::mojom::AuthenticationAndCertificateObserver>
 RenderFrameHostImpl::CreateAuthAndCertObserver() {
   return static_cast<StoragePartitionImpl*>(GetStoragePartition())
