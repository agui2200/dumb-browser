diff --git a/components/autofill/core/browser/autofill_manager.cc b/components/autofill/core/browser/autofill_manager.cc
index a9dd2e727ddb..15e62a0f312c 100644
--- a/components/autofill/core/browser/autofill_manager.cc
+++ b/components/autofill/core/browser/autofill_manager.cc
@@ -47,7 +47,6 @@
 #include "components/autofill/core/browser/autofill_external_delegate.h"
 #include "components/autofill/core/browser/autofill_field.h"
 #include "components/autofill/core/browser/autofill_manager_test_delegate.h"
-#include "components/autofill/core/browser/autofill_metrics.h"
 #include "components/autofill/core/browser/autofill_type.h"
 #include "components/autofill/core/browser/data_model/autofill_data_model.h"
 #include "components/autofill/core/browser/data_model/autofill_profile.h"
@@ -60,7 +59,6 @@
 #include "components/autofill/core/browser/geo/country_names.h"
 #include "components/autofill/core/browser/geo/phone_number_i18n.h"
 #include "components/autofill/core/browser/logging/log_manager.h"
-#include "components/autofill/core/browser/metrics/form_events.h"
 #include "components/autofill/core/browser/payments/autofill_offer_manager.h"
 #include "components/autofill/core/browser/payments/credit_card_access_manager.h"
 #include "components/autofill/core/browser/payments/payments_client.h"
@@ -96,10 +94,6 @@
 #include "ui/gfx/geometry/rect.h"
 #include "url/gurl.h"
 
-#if defined(OS_IOS)
-#include "components/autofill/core/browser/keyboard_accessory_metrics_logger.h"
-#endif
-
 namespace autofill {
 
 using base::StartsWith;
@@ -174,19 +168,6 @@ void SelectRightNameType(AutofillField* field, bool is_credit_card) {
   field->set_possible_types_validities(new_types_validities);
 }
 
-void LogDeveloperEngagementUkm(ukm::UkmRecorder* ukm_recorder,
-                               ukm::SourceId source_id,
-                               FormStructure* form_structure) {
-  if (form_structure->developer_engagement_metrics()) {
-    AutofillMetrics::LogDeveloperEngagementUkm(
-        ukm_recorder, source_id, form_structure->main_frame_origin().GetURL(),
-        form_structure->IsCompleteCreditCardForm(),
-        form_structure->GetFormTypes(),
-        form_structure->developer_engagement_metrics(),
-        form_structure->form_signature());
-  }
-}
-
 std::string GetAPIKeyForUrl(version_info::Channel channel) {
   // First look if we can get API key from command line flag.
   const base::CommandLine& command_line =
@@ -200,38 +181,6 @@ std::string GetAPIKeyForUrl(version_info::Channel channel) {
   return google_apis::GetNonStableAPIKey();
 }
 
-ValuePatternsMetric GetValuePattern(const base::string16& value) {
-  if (IsUPIVirtualPaymentAddress(value))
-    return ValuePatternsMetric::kUpiVpa;
-  if (IsInternationalBankAccountNumber(value))
-    return ValuePatternsMetric::kIban;
-  return ValuePatternsMetric::kNoPatternFound;
-}
-
-void LogValuePatternsMetric(const FormData& form) {
-  for (const FormFieldData& field : form.fields) {
-    if (!field.IsVisible()) {
-      // Ignore hidden fields.
-      continue;
-    }
-    base::string16 value;
-    base::TrimWhitespace(field.value, base::TRIM_ALL, &value);
-    if (value.empty())
-      continue;
-    base::UmaHistogramEnumeration("Autofill.SubmittedValuePatterns",
-                                  GetValuePattern(value));
-  }
-}
-
-void LogLanguageMetrics(const translate::LanguageState* language_state) {
-  if (language_state) {
-    AutofillMetrics::LogFieldParsingTranslatedFormLanguageMetric(
-        language_state->current_language());
-    AutofillMetrics::LogFieldParsingPageTranslationStatusMetric(
-        language_state->IsPageTranslated());
-  }
-}
-
 bool IsAddressForm(FieldTypeGroup field_type_group) {
   switch (field_type_group) {
     case NAME:
@@ -657,12 +606,6 @@ bool AutofillManager::ShouldParseForms(const std::vector<FormData>& forms,
   sync_state_ = personal_data_ ? personal_data_->GetSyncSigninState()
                                : AutofillSyncSigninState::kNumSyncStates;
   if (!has_logged_autofill_enabled_) {
-    AutofillMetrics::LogIsAutofillEnabledAtPageLoad(autofill_enabled,
-                                                    sync_state_);
-    AutofillMetrics::LogIsAutofillProfileEnabledAtPageLoad(
-        IsAutofillProfileEnabled(), sync_state_);
-    AutofillMetrics::LogIsAutofillCreditCardEnabledAtPageLoad(
-        IsAutofillCreditCardEnabled(), sync_state_);
     has_logged_autofill_enabled_ = true;
   }
 
@@ -680,12 +623,6 @@ void AutofillManager::OnFormSubmittedImpl(const FormData& form,
                         << Br{} << form;
   }
 
-  // Always upload page language metrics.
-  LogLanguageMetrics(client_->GetLanguageState());
-
-  // Always let the value patterns metric upload data.
-  LogValuePatternsMetric(form);
-
   // We will always give Autocomplete a chance to save the data.
   std::unique_ptr<FormStructure> submitted_form = ValidateSubmittedForm(form);
   if (!submitted_form) {
@@ -706,14 +643,6 @@ void AutofillManager::OnFormSubmittedImpl(const FormData& form,
   autocomplete_history_manager_->OnWillSubmitForm(
       form_for_autocomplete, client_->IsAutocompleteEnabled());
 
-  if (IsAutofillProfileEnabled()) {
-    address_form_event_logger_->OnWillSubmitForm(sync_state_, *submitted_form);
-  }
-  if (IsAutofillCreditCardEnabled()) {
-    credit_card_form_event_logger_->OnWillSubmitForm(sync_state_,
-                                                     *submitted_form);
-  }
-
   submitted_form->set_submission_source(source);
   MaybeStartVoteUploadProcess(std::move(submitted_form),
                               /*observed_submission=*/true);
@@ -727,15 +656,6 @@ void AutofillManager::OnFormSubmittedImpl(const FormData& form,
 
   submitted_form->set_submission_source(source);
 
-  if (IsAutofillProfileEnabled()) {
-    address_form_event_logger_->OnFormSubmitted(/*force_logging=*/false,
-                                                sync_state_, *submitted_form);
-  }
-  if (IsAutofillCreditCardEnabled()) {
-    credit_card_form_event_logger_->OnFormSubmitted(
-        enable_ablation_logging_, sync_state_, *submitted_form);
-  }
-
   if (!submitted_form->IsAutofillable() &&
       !ContainsAutofillableValue(*submitted_form)) {
     return;
@@ -760,10 +680,6 @@ bool AutofillManager::MaybeStartVoteUploadProcess(
   // is available to use as a baseline.
   std::vector<AutofillProfile*> profiles = personal_data_->GetProfiles();
   personal_data_->UpdateProfilesServerValidityMapsIfNeeded(profiles);
-  if (observed_submission && form_structure->IsAutofillable()) {
-    AutofillMetrics::LogNumberOfProfilesAtAutofillableFormSubmission(
-        personal_data_->GetProfiles().size());
-  }
 
   const std::vector<CreditCard*>& credit_cards =
       credit_card_access_manager_->GetCreditCards();
@@ -854,10 +770,6 @@ void AutofillManager::DidSuppressPopup(const FormData& form,
   AutofillField* autofill_field = nullptr;
   if (!GetCachedFormAndField(form, field, &form_structure, &autofill_field))
     return;
-
-  auto* logger = GetEventFormLogger(autofill_field->Type().group());
-  if (logger)
-    logger->OnPopupSuppressed(*form_structure, *autofill_field);
 }
 
 void AutofillManager::OnTextFieldDidChangeImpl(const FormData& form,
@@ -874,44 +786,16 @@ void AutofillManager::OnTextFieldDidChangeImpl(const FormData& form,
 
   UpdatePendingForm(form);
 
-  uint32_t profile_form_bitmask = 0;
-  if (!user_did_type_ || autofill_field->is_autofilled) {
-    form_interactions_ukm_logger_->LogTextFieldDidChange(*form_structure,
-                                                         *autofill_field);
-    profile_form_bitmask = data_util::DetermineGroups(*form_structure);
-  }
-
-  if (!autofill_field->is_autofilled) {
-    auto* logger = GetEventFormLogger(autofill_field->Type().group());
-    if (logger)
-      logger->OnTypedIntoNonFilledField();
-  }
-
   if (!user_did_type_) {
     user_did_type_ = true;
-    AutofillMetrics::LogUserHappinessMetric(
-        AutofillMetrics::USER_DID_TYPE, autofill_field->Type().group(),
-        client_->GetSecurityLevelForUmaHistograms(), profile_form_bitmask);
   }
 
   if (autofill_field->is_autofilled) {
     autofill_field->is_autofilled = false;
     autofill_field->set_previously_autofilled(true);
-    AutofillMetrics::LogUserHappinessMetric(
-        AutofillMetrics::USER_DID_EDIT_AUTOFILLED_FIELD,
-        autofill_field->Type().group(),
-        client_->GetSecurityLevelForUmaHistograms(), profile_form_bitmask);
-
-    auto* logger = GetEventFormLogger(autofill_field->Type().group());
-    if (logger)
-      logger->OnEditedAutofilledField();
 
     if (!user_did_edit_autofilled_field_) {
       user_did_edit_autofilled_field_ = true;
-      AutofillMetrics::LogUserHappinessMetric(
-          AutofillMetrics::USER_DID_EDIT_AUTOFILLED_FIELD_ONCE,
-          autofill_field->Type().group(),
-          client_->GetSecurityLevelForUmaHistograms(), profile_form_bitmask);
     }
   }
 
@@ -953,17 +837,11 @@ void AutofillManager::OnQueryFormFieldAutofillImpl(
     }
 
     if (!suggestions.empty()) {
-      if (context.is_filling_credit_card) {
-        AutofillMetrics::LogIsQueriedCreditCardFormSecure(
-            context.is_context_secure);
-      }
-
       // The first time we show suggestions on this page, log the number of
       // suggestions available.
       // TODO(mathp): Differentiate between number of suggestions available
       // (current metric) and number shown to the user.
       if (!has_logged_address_suggestions_count_) {
-        AutofillMetrics::LogAddressSuggestionsCount(suggestions.size());
         has_logged_address_suggestions_count_ = true;
       }
     }
@@ -1041,9 +919,6 @@ void AutofillManager::FillOrPreviewCreditCardForm(
   bool should_fetch_card = !is_preview && WillFillCreditCardNumber(form, field);
 
   if (should_fetch_card) {
-    credit_card_form_event_logger_->OnDidSelectCardSuggestion(
-        credit_card_, *form_structure, sync_state_);
-
     credit_card_action_ = action;
     credit_card_query_id_ = query_id;
     credit_card_form_ = form;
@@ -1057,11 +932,6 @@ void AutofillManager::FillOrPreviewCreditCardForm(
     return;
   }
 
-  if (!is_preview) {
-    credit_card_form_event_logger_->OnDidFillSuggestion(
-        credit_card_, *form_structure, *autofill_field, sync_state_);
-  }
-
   FillOrPreviewDataModelForm(action, query_id, form, field, /*profile=*/nullptr,
                              &credit_card_, /*cvc=*/nullptr, form_structure,
                              autofill_field);
@@ -1077,10 +947,6 @@ void AutofillManager::FillOrPreviewProfileForm(
   AutofillField* autofill_field = nullptr;
   if (!GetCachedFormAndField(form, field, &form_structure, &autofill_field))
     return;
-  if (action == AutofillDriver::FORM_DATA_ACTION_FILL) {
-    address_form_event_logger_->OnDidFillSuggestion(
-        profile, *form_structure, *autofill_field, sync_state_);
-  }
 
   FillOrPreviewDataModelForm(action, query_id, form, field, &profile,
                              /*credit_card=*/nullptr,
@@ -1206,17 +1072,8 @@ void AutofillManager::OnDidFillAutofillFormData(const FormData& form,
     form_types = form_structure->GetFormTypes();
   }
 
-  uint32_t profile_form_bitmask =
-      form_structure ? data_util::DetermineGroups(*form_structure) : 0;
-
-  AutofillMetrics::LogUserHappinessMetric(
-      AutofillMetrics::USER_DID_AUTOFILL, form_types,
-      client_->GetSecurityLevelForUmaHistograms(), profile_form_bitmask);
   if (!user_did_autofill_) {
     user_did_autofill_ = true;
-    AutofillMetrics::LogUserHappinessMetric(
-        AutofillMetrics::USER_DID_AUTOFILL_ONCE, form_types,
-        client_->GetSecurityLevelForUmaHistograms(), profile_form_bitmask);
   }
 
   UpdateInitialInteractionTimestamp(timestamp);
@@ -1231,7 +1088,6 @@ void AutofillManager::DidShowSuggestions(bool has_autofill_suggestions,
   if (!has_autofill_suggestions) {
     // If suggestions are not from Autofill, then it means they are from
     // Autocomplete.
-    AutofillMetrics::OnAutocompleteSuggestionsShown();
     return;
   }
 
@@ -1240,23 +1096,8 @@ void AutofillManager::DidShowSuggestions(bool has_autofill_suggestions,
   if (!GetCachedFormAndField(form, field, &form_structure, &autofill_field))
     return;
 
-  uint32_t profile_form_bitmask = data_util::DetermineGroups(*form_structure);
-  AutofillMetrics::LogUserHappinessMetric(
-      AutofillMetrics::SUGGESTIONS_SHOWN, autofill_field->Type().group(),
-      client_->GetSecurityLevelForUmaHistograms(), profile_form_bitmask);
-
   if (!did_show_suggestions_) {
     did_show_suggestions_ = true;
-    AutofillMetrics::LogUserHappinessMetric(
-        AutofillMetrics::SUGGESTIONS_SHOWN_ONCE, autofill_field->Type().group(),
-        client_->GetSecurityLevelForUmaHistograms(), profile_form_bitmask);
-  }
-
-  auto* logger = GetEventFormLogger(autofill_field->Type().group());
-  if (logger) {
-    logger->OnDidShowSuggestions(*form_structure, *autofill_field,
-                                 form_structure->form_parsed_timestamp(),
-                                 sync_state_, driver()->IsIncognito());
   }
 
   if (autofill_field->Type().group() == CREDIT_CARD &&
@@ -1357,10 +1198,6 @@ void AutofillManager::OnUserHideSuggestions(const FormData& form,
   AutofillField* autofill_field = nullptr;
   if (!GetCachedFormAndField(form, field, &form_structure, &autofill_field))
     return;
-
-  auto* logger = GetEventFormLogger(autofill_field->Type().group());
-  if (logger)
-    logger->OnUserHideSuggestions(*form_structure, *autofill_field);
 }
 
 bool AutofillManager::ShouldClearPreviewedForm() {
@@ -1433,15 +1270,7 @@ void AutofillManager::OnLoadedServerPredictions(
 
   // Parse and store the server predictions.
   FormStructure::ParseApiQueryResponse(std::move(response), queried_forms,
-                                       queried_form_signatures,
-                                       form_interactions_ukm_logger_.get());
-
-  // Will log quality metrics for each FormStructure based on the presence of
-  // autocomplete attributes, if available.
-  for (FormStructure* cur_form : queried_forms) {
-    cur_form->LogQualityMetricsBasedOnAutocomplete(
-        form_interactions_ukm_logger_.get());
-  }
+                                       queried_form_signatures);
 
   // Send field type predictions to the renderer so that it can possibly
   // annotate forms with the predicted types or add console warnings.
@@ -1470,12 +1299,6 @@ void AutofillManager::OnCreditCardFetched(bool did_succeed,
                              &form_structure, &autofill_field))
     return;
 
-  // The originally selected masked card is |credit_card_|. So we must log
-  // |credit_card_| as opposed to |credit_card| to correctly indicate that the
-  // user filled the form using a masked card suggestion.
-  credit_card_form_event_logger_->OnDidFillSuggestion(
-      credit_card_, *form_structure, *autofill_field, sync_state_);
-
   DCHECK(credit_card);
   FillCreditCardForm(credit_card_query_id_, credit_card_form_,
                      credit_card_field_, *credit_card, cvc);
@@ -1535,13 +1358,6 @@ void AutofillManager::UploadFormDataAsyncCallback(
     const TimeTicks& interaction_time,
     const TimeTicks& submission_time,
     bool observed_submission) {
-  if (submitted_form->ShouldRunHeuristics() ||
-      submitted_form->ShouldBeQueried()) {
-    submitted_form->LogQualityMetrics(
-        submitted_form->form_parsed_timestamp(), interaction_time,
-        submission_time, form_interactions_ukm_logger_.get(),
-        did_show_suggestions_, observed_submission);
-  }
   if (submitted_form->ShouldBeUploaded())
     UploadFormData(*submitted_form, observed_submission);
 }
@@ -1581,16 +1397,8 @@ void AutofillManager::Reset() {
   ProcessPendingFormForUpload();
   DCHECK(!pending_form_data_);
   AutofillHandler::Reset();
-  form_interactions_ukm_logger_.reset(
-      new AutofillMetrics::FormInteractionsUkmLogger(
-          client_->GetUkmRecorder(), client_->GetUkmSourceId()));
-  address_form_event_logger_.reset(new AddressFormEventLogger(
-      driver()->IsInMainFrame(), form_interactions_ukm_logger_.get(), client_));
-  credit_card_form_event_logger_.reset(new CreditCardFormEventLogger(
-      driver()->IsInMainFrame(), form_interactions_ukm_logger_.get(),
-      personal_data_, client_));
   credit_card_access_manager_.reset(new CreditCardAccessManager(
-      driver(), client_, personal_data_, credit_card_form_event_logger_.get()));
+      driver(), client_, personal_data_));
 
   has_logged_autofill_enabled_ = false;
   has_logged_address_suggestions_count_ = false;
@@ -1625,28 +1433,13 @@ AutofillManager::AutofillManager(
       personal_data_(personal_data),
       field_filler_(app_locale, client->GetAddressNormalizer()),
       autocomplete_history_manager_(autocomplete_history_manager->GetWeakPtr()),
-      form_interactions_ukm_logger_(
-          std::make_unique<AutofillMetrics::FormInteractionsUkmLogger>(
-              client->GetUkmRecorder(),
-              client->GetUkmSourceId())),
-      address_form_event_logger_(std::make_unique<AddressFormEventLogger>(
-          driver->IsInMainFrame(),
-          form_interactions_ukm_logger_.get(),
-          client_)),
-      credit_card_form_event_logger_(
-          std::make_unique<CreditCardFormEventLogger>(
-              driver->IsInMainFrame(),
-              form_interactions_ukm_logger_.get(),
-              personal_data_,
-              client_)),
       is_rich_query_enabled_(IsRichQueryEnabled(client->GetChannel())) {
   DCHECK(driver);
   DCHECK(client_);
   credit_card_access_manager_ = cc_access_manager
                                     ? std::move(cc_access_manager)
                                     : std::make_unique<CreditCardAccessManager>(
-                                          driver, client_, personal_data_,
-                                          credit_card_form_event_logger_.get());
+                                          driver, client_, personal_data_);
   if (enable_download_manager == ENABLE_AUTOFILL_DOWNLOAD_MANAGER) {
     version_info::Channel channel = client_->GetChannel();
     download_manager_.reset(new AutofillDownloadManager(
@@ -1662,23 +1455,6 @@ bool AutofillManager::RefreshDataModels() {
 
   // No autofill data to return if the profiles are empty.
   const std::vector<AutofillProfile*>& profiles = personal_data_->GetProfiles();
-  credit_card_access_manager_->UpdateCreditCardFormEventLogger();
-
-  // Updating the FormEventLogger for addresses.
-  {
-    size_t server_record_type_count = 0;
-    size_t local_record_type_count = 0;
-    for (AutofillProfile* profile : profiles) {
-      if (profile->record_type() == AutofillProfile::LOCAL_PROFILE)
-        local_record_type_count++;
-      else if (profile->record_type() == AutofillProfile::SERVER_PROFILE)
-        server_record_type_count++;
-    }
-    address_form_event_logger_->set_server_record_type_count(
-        server_record_type_count);
-    address_form_event_logger_->set_local_record_type_count(
-        local_record_type_count);
-  }
 
   return !profiles.empty() ||
          !credit_card_access_manager_->GetCreditCards().empty();
@@ -1789,8 +1565,6 @@ void AutofillManager::FillOrPreviewDataModelForm(
     // the sake of filling the synthetic fields.
     if (!cached_field->IsVisible()) {
       bool skip = result.fields[i].form_control_type != "select-one";
-      form_interactions_ukm_logger_->LogHiddenRepresentationalFieldSkipDecision(
-          *form_structure, *cached_field, skip);
       if (skip) {
         buffer << Tr{} << field_number << "Skipped: invisible field";
         continue;
@@ -1896,9 +1670,6 @@ void AutofillManager::FillOrPreviewDataModelForm(
                   "Fillable - has value: %d->%d; autofilled: %d->%d. %s",
                   has_value_before, is_autofilled_before, has_value_after,
                   is_autofilled_after, failure_to_fill.c_str());
-
-    if (!cached_field->IsVisible() && result.fields[i].is_autofilled)
-      AutofillMetrics::LogHiddenOrPresentationalSelectFieldsFilled();
   }
   buffer << CTag{"table"};
 
@@ -1973,8 +1744,6 @@ std::vector<Suggestion> AutofillManager::GetProfileSuggestions(
     const FormStructure& form,
     const FormFieldData& field,
     const AutofillField& autofill_field) const {
-  address_form_event_logger_->OnDidPollSuggestions(field, sync_state_);
-
   std::vector<ServerFieldType> field_types(form.field_count());
   for (size_t i = 0; i < form.field_count(); ++i) {
     field_types.push_back(form.field(i)->Type().GetStorableType());
@@ -2002,8 +1771,6 @@ std::vector<Suggestion> AutofillManager::GetCreditCardSuggestions(
     const FormFieldData& field,
     const AutofillType& type,
     bool* should_display_gpay_logo) const {
-  credit_card_form_event_logger_->OnDidPollSuggestions(field, sync_state_);
-
   // The field value is sanitized before attempting to match it to the user's
   // data.
   std::vector<Suggestion> suggestions =
@@ -2024,7 +1791,6 @@ std::vector<Suggestion> AutofillManager::GetCreditCardSuggestions(
         MakeFrontendID(suggestions[i].backend_id, std::string());
   }
 
-  credit_card_form_event_logger_->set_suggestions(suggestions);
   return suggestions;
 }
 
@@ -2036,9 +1802,6 @@ void AutofillManager::OnFormsParsed(const std::vector<const FormData*>& forms,
   // Record the current sync state to be used for metrics on this page.
   sync_state_ = personal_data_->GetSyncSigninState();
 
-  // Setup the url for metrics that we will collect for this form.
-  form_interactions_ukm_logger_->OnFormsParsed(client_->GetUkmSourceId());
-
   driver()->HandleParsedForms(forms);
 
   std::vector<FormStructure*> non_queryable_forms;
@@ -2056,10 +1819,6 @@ void AutofillManager::OnFormsParsed(const std::vector<const FormData*>& forms,
       has_observed_phone_number_field_ = true;
     }
 
-    // TODO(crbug.com/869482): avoid logging developer engagement multiple
-    // times for a given form if it or other forms on the page are dynamic.
-    LogDeveloperEngagementUkm(client_->GetUkmRecorder(),
-                              client_->GetUkmSourceId(), form_structure);
     std::set<FormType> current_form_types = form_structure->GetFormTypes();
     form_types.insert(current_form_types.begin(), current_form_types.end());
 
@@ -2083,12 +1842,6 @@ void AutofillManager::OnFormsParsed(const std::vector<const FormData*>& forms,
         has_observed_one_time_code_field_ = true;
       }
     }
-    if (card_form) {
-      credit_card_form_event_logger_->OnDidParseForm(*form_structure);
-    }
-    if (address_form) {
-      address_form_event_logger_->OnDidParseForm(*form_structure);
-    }
 
     // If a form with the same name was previously filled, and there has not
     // been a refill attempt on that form yet, start the process of triggering a
@@ -2113,20 +1866,6 @@ void AutofillManager::OnFormsParsed(const std::vector<const FormData*>& forms,
     }
   }
 
-  if (!queryable_forms.empty() || !non_queryable_forms.empty()) {
-    AutofillMetrics::LogUserHappinessMetric(
-        AutofillMetrics::FORMS_LOADED, form_types,
-        client_->GetSecurityLevelForUmaHistograms(),
-        /*profile_form_bitmask=*/0);
-
-#if defined(OS_IOS)
-    // Log this from same location as AutofillMetrics::FORMS_LOADED to ensure
-    // that KeyboardAccessoryButtonsIOS and UserHappiness UMA metrics will be
-    // directly comparable.
-    KeyboardAccessoryMetricsLogger::OnFormsLoaded();
-#endif
-  }
-
   // Send the current type predictions to the renderer. For non-queryable forms
   // this is all the information about them that will ever be available. The
   // queryable forms will be updated once the field type query is complete.
@@ -2451,9 +2190,6 @@ void AutofillManager::FillFieldWithValue(AutofillField* autofill_field,
     // it. This allows the renderer to distinguish autofilled fields from
     // fields with non-empty values, such as select-one fields.
     field_data->is_autofilled = true;
-    AutofillMetrics::LogUserHappinessMetric(
-        AutofillMetrics::FIELD_WAS_AUTOFILLED, autofill_field->Type().group(),
-        client_->GetSecurityLevelForUmaHistograms(), profile_form_bitmask);
 
     if (should_notify) {
       client_->DidFillOrPreviewField(
@@ -2472,19 +2208,10 @@ bool AutofillManager::ShouldTriggerRefill(const FormStructure& form_structure) {
   if (itr == filling_contexts_map_.end())
     return false;
 
-  address_form_event_logger_->OnDidSeeFillableDynamicForm(sync_state_,
-                                                          form_structure);
-
   FillingContext* filling_context = itr->second.get();
   base::TimeTicks now = AutofillTickClock::NowTicks();
   base::TimeDelta delta = now - filling_context->original_fill_time;
 
-  if (filling_context->attempted_refill &&
-      delta.InMilliseconds() < kLimitBeforeRefillMs) {
-    address_form_event_logger_->OnSubsequentRefillAttempt(sync_state_,
-                                                          form_structure);
-  }
-
   return !filling_context->attempted_refill &&
          delta.InMilliseconds() < kLimitBeforeRefillMs;
 }
@@ -2497,8 +2224,6 @@ void AutofillManager::TriggerRefill(const FormData& form) {
 
   DCHECK(form_structure);
 
-  address_form_event_logger_->OnDidRefill(sync_state_, *form_structure);
-
   auto itr =
       filling_contexts_map_.find(form_structure->GetIdentifierForRefill());
 
@@ -2573,11 +2298,6 @@ void AutofillManager::GetAvailableSuggestions(
     if (context->focused_field->Type().group() == CREDIT_CARD) {
       context->is_filling_credit_card = true;
     }
-    auto* logger = GetEventFormLogger(context->focused_field->Type().group());
-    if (logger) {
-      logger->OnDidInteractWithAutofillableForm(*(context->form_structure),
-                                                sync_state_);
-    }
   }
 
   // If the feature is enabled and this is a mixed content form, we show a
@@ -2711,31 +2431,6 @@ bool AutofillManager::ShouldShowVirtualCardOption(
 }
 #endif
 
-FormEventLoggerBase* AutofillManager::GetEventFormLogger(
-    FieldTypeGroup field_type_group) const {
-  switch (field_type_group) {
-    case NAME:
-    case NAME_BILLING:
-    case EMAIL:
-    case COMPANY:
-    case ADDRESS_HOME:
-    case ADDRESS_BILLING:
-    case PHONE_HOME:
-    case PHONE_BILLING:
-      return address_form_event_logger_.get();
-    case CREDIT_CARD:
-      return credit_card_form_event_logger_.get();
-    case TRANSACTION:
-    case PASSWORD_FIELD:
-    case USERNAME_FIELD:
-    case NO_GROUP:
-    case UNFILLABLE:
-      return nullptr;
-  }
-  NOTREACHED();
-  return nullptr;
-}
-
 std::string AutofillManager::GetPageLanguage() const {
   DCHECK(client_);
   const translate::LanguageState* language_state = client_->GetLanguageState();
