diff --git a/content/renderer/render_thread_impl.cc b/content/renderer/render_thread_impl.cc
index a4240c7c75a3..cf9354c16671 100644
--- a/content/renderer/render_thread_impl.cc
+++ b/content/renderer/render_thread_impl.cc
@@ -50,7 +50,6 @@
 #include "cc/raster/task_graph_runner.h"
 #include "cc/trees/layer_tree_frame_sink.h"
 #include "cc/trees/layer_tree_settings.h"
-#include "cc/trees/ukm_manager.h"
 #include "components/discardable_memory/client/client_discardable_shared_memory_manager.h"
 #include "components/metrics/public/mojom/single_sample_metrics.mojom.h"
 #include "components/metrics/single_sample_metrics.h"
@@ -112,7 +111,6 @@
 #include "net/base/registry_controlled_domains/registry_controlled_domain.h"
 #include "net/base/url_util.h"
 #include "ppapi/buildflags/buildflags.h"
-#include "services/metrics/public/cpp/mojo_ukm_recorder.h"
 #include "services/network/public/cpp/network_switches.h"
 #include "services/service_manager/public/cpp/interface_provider.h"
 #include "services/viz/public/cpp/gpu/context_provider_command_buffer.h"
@@ -355,25 +353,6 @@ void CreateSingleSampleMetricsProvider(
   process_host->BindHostReceiver(std::move(receiver));
 }
 
-// This factory is used to defer binding of the InterfacePtr to the compositor
-// thread.
-class UkmRecorderFactoryImpl : public cc::UkmRecorderFactory {
- public:
-  explicit UkmRecorderFactoryImpl(
-      mojo::SharedRemote<mojom::ChildProcessHost> process_host)
-      : process_host_(std::move(process_host)) {}
-  ~UkmRecorderFactoryImpl() override = default;
-
-  std::unique_ptr<ukm::UkmRecorder> CreateRecorder() override {
-    mojo::PendingRemote<ukm::mojom::UkmRecorderInterface> recorder;
-    process_host_->BindHostReceiver(recorder.InitWithNewPipeAndPassReceiver());
-    return std::make_unique<ukm::MojoUkmRecorder>(std::move(recorder));
-  }
-
- private:
-  const mojo::SharedRemote<mojom::ChildProcessHost> process_host_;
-};
-
 }  // namespace
 
 RenderThreadImpl::HistogramCustomizer::HistogramCustomizer() {
@@ -1353,11 +1332,6 @@ void RenderThreadImpl::SetScrollAnimatorEnabled(
   is_scroll_animator_enabled_ = enable_scroll_animator;
 }
 
-std::unique_ptr<cc::UkmRecorderFactory>
-RenderThreadImpl::CreateUkmRecorderFactory() {
-  return std::make_unique<UkmRecorderFactoryImpl>(child_process_host());
-}
-
 bool RenderThreadImpl::IsMainThread() {
   return !!current();
 }
@@ -1487,45 +1461,9 @@ bool RenderThreadImpl::GetRendererMemoryMetrics(
   return true;
 }
 
-static void RecordMemoryUsageAfterBackgroundedMB(const char* basename,
-                                                 const char* suffix,
-                                                 int memory_usage) {
-  std::string histogram_name = base::StringPrintf("%s.%s", basename, suffix);
-  base::UmaHistogramMemoryLargeMB(histogram_name, memory_usage);
-}
-
 void RenderThreadImpl::RecordMemoryUsageAfterBackgrounded(
     const char* suffix,
     int foregrounded_count) {
-  // If this renderer is resumed, we should not update UMA.
-  if (!RendererIsHidden())
-    return;
-  // If this renderer was not kept backgrounded for 5/10/15 minutes,
-  // we should not record current memory usage.
-  if (foregrounded_count != process_foregrounded_count_)
-    return;
-
-  RendererMemoryMetrics memory_metrics;
-  if (!GetRendererMemoryMetrics(&memory_metrics))
-    return;
-  RecordMemoryUsageAfterBackgroundedMB(
-      "Memory.Experimental.Renderer.PartitionAlloc.AfterBackgrounded", suffix,
-      memory_metrics.partition_alloc_kb / 1024);
-  RecordMemoryUsageAfterBackgroundedMB(
-      "Memory.Experimental.Renderer.BlinkGC.AfterBackgrounded", suffix,
-      memory_metrics.blink_gc_kb / 1024);
-  RecordMemoryUsageAfterBackgroundedMB(
-      "Memory.Experimental.Renderer.Malloc.AfterBackgrounded", suffix,
-      memory_metrics.malloc_mb);
-  RecordMemoryUsageAfterBackgroundedMB(
-      "Memory.Experimental.Renderer.Discardable.AfterBackgrounded", suffix,
-      memory_metrics.discardable_kb / 1024);
-  RecordMemoryUsageAfterBackgroundedMB(
-      "Memory.Experimental.Renderer.V8MainThreaIsolate.AfterBackgrounded",
-      suffix, memory_metrics.v8_main_thread_isolate_mb);
-  RecordMemoryUsageAfterBackgroundedMB(
-      "Memory.Experimental.Renderer.TotalAllocated.AfterBackgrounded", suffix,
-      memory_metrics.total_allocated_mb);
 }
 
 #define GET_MEMORY_GROWTH(current, previous, allocator) \
@@ -1905,24 +1843,6 @@ bool RenderThreadImpl::RendererIsBackgrounded() const {
 void RenderThreadImpl::OnRendererBackgrounded() {
   main_thread_scheduler_->SetRendererBackgrounded(true);
   discardable_memory_allocator_->OnBackgrounded();
-  GetWebMainThreadScheduler()->DefaultTaskRunner()->PostDelayedTask(
-      FROM_HERE,
-      base::BindOnce(&RenderThreadImpl::RecordMemoryUsageAfterBackgrounded,
-                     base::Unretained(this), "5min",
-                     process_foregrounded_count_),
-      base::TimeDelta::FromMinutes(5));
-  GetWebMainThreadScheduler()->DefaultTaskRunner()->PostDelayedTask(
-      FROM_HERE,
-      base::BindOnce(&RenderThreadImpl::RecordMemoryUsageAfterBackgrounded,
-                     base::Unretained(this), "10min",
-                     process_foregrounded_count_),
-      base::TimeDelta::FromMinutes(10));
-  GetWebMainThreadScheduler()->DefaultTaskRunner()->PostDelayedTask(
-      FROM_HERE,
-      base::BindOnce(&RenderThreadImpl::RecordMemoryUsageAfterBackgrounded,
-                     base::Unretained(this), "15min",
-                     process_foregrounded_count_),
-      base::TimeDelta::FromMinutes(15));
 }
 
 void RenderThreadImpl::OnRendererForegrounded() {
