diff --git a/content/browser/service_worker/embedded_worker_instance.cc b/content/browser/service_worker/embedded_worker_instance.cc
index dcd1f109de9e..46662821ee35 100644
--- a/content/browser/service_worker/embedded_worker_instance.cc
+++ b/content/browser/service_worker/embedded_worker_instance.cc
@@ -19,7 +19,6 @@
 #include "content/browser/data_url_loader_factory.h"
 #include "content/browser/devtools/devtools_instrumentation.h"
 #include "content/browser/devtools/service_worker_devtools_manager.h"
-#include "content/browser/net/cross_origin_embedder_policy_reporter.h"
 #include "content/browser/renderer_host/render_process_host_impl.h"
 #include "content/browser/service_worker/embedded_worker_status.h"
 #include "content/browser/service_worker/service_worker_consts.h"
@@ -266,8 +265,6 @@ void EmbeddedWorkerInstance::Start(
       factory_bundle_for_new_scripts;
   std::unique_ptr<blink::PendingURLLoaderFactoryBundle>
       factory_bundle_for_renderer;
-  mojo::PendingReceiver<blink::mojom::ReportingObserver>
-      reporting_observer_receiver;
 
   ServiceWorkerProcessManager* process_manager = context_->process_manager();
   if (!process_manager) {
@@ -300,52 +297,13 @@ void EmbeddedWorkerInstance::Start(
       base::BindOnce(&EmbeddedWorkerInstance::Detach, base::Unretained(this)));
 
   {
-    // Create COEP reporter if COEP value is already available (= this worker is
-    // not a worker which is going to be newly registered). The Mojo remote
-    // `coep_reporter_` has the onwership of the instance. The `coep_reporter`
-    // might be kept null when the COEP value is not known because the main
-    // script has not been loaded yet. In that case, it will be bound after the
-    // main script is loaded.
-    mojo::PendingRemote<network::mojom::CrossOriginEmbedderPolicyReporter>
-        coep_reporter_for_devtools;
-    mojo::PendingRemote<network::mojom::CrossOriginEmbedderPolicyReporter>
-        coep_reporter_for_scripts;
-    mojo::PendingRemote<network::mojom::CrossOriginEmbedderPolicyReporter>
-        coep_reporter_for_subresources;
-    if (owner_version_->cross_origin_embedder_policy()) {
-      mojo::PendingRemote<blink::mojom::ReportingObserver>
-          reporting_observer_remote;
-      owner_version_->set_reporting_observer_receiver(
-          reporting_observer_remote.InitWithNewPipeAndPassReceiver());
-      auto reporter = std::make_unique<CrossOriginEmbedderPolicyReporter>(
-          rph->GetStoragePartition(), params->script_url,
-          owner_version_->cross_origin_embedder_policy()->reporting_endpoint,
-          owner_version_->cross_origin_embedder_policy()
-              ->report_only_reporting_endpoint,
-          // TODO(https://crbug.com/1147281): This is the NetworkIsolationKey of
-          // a top-level browsing context, which shouldn't be use for
-          // ServiceWorkers used in iframes.
-          net::NetworkIsolationKey::ToDoUseTopFrameOriginAsWell(
-              url::Origin::Create(params->script_url)));
-      reporter->BindObserver(std::move(reporting_observer_remote));
-      mojo::MakeSelfOwnedReceiver(std::move(reporter),
-                                  coep_reporter_.BindNewPipeAndPassReceiver());
-
-      coep_reporter_->Clone(
-          coep_reporter_for_devtools.InitWithNewPipeAndPassReceiver());
-      coep_reporter_->Clone(
-          coep_reporter_for_scripts.InitWithNewPipeAndPassReceiver());
-      coep_reporter_->Clone(
-          coep_reporter_for_subresources.InitWithNewPipeAndPassReceiver());
-    }
-
     // Register to DevTools and update params accordingly.
     const int routing_id = rph->GetNextRoutingID();
     ServiceWorkerDevToolsManager::GetInstance()->WorkerStarting(
         process_id, routing_id, context_->wrapper(),
         params->service_worker_version_id, params->script_url, params->scope,
         params->is_installed, owner_version_->cross_origin_embedder_policy(),
-        std::move(coep_reporter_for_devtools), &params->devtools_worker_token,
+        &params->devtools_worker_token,
         &params->wait_for_debugger);
     params->service_worker_route_id = routing_id;
     // Create DevToolsProxy here to ensure that the WorkerCreated() call is
@@ -367,7 +325,6 @@ void EmbeddedWorkerInstance::Start(
           EmbeddedWorkerInstance::CreateFactoryBundle(
               rph, routing_id, origin,
               owner_version_->cross_origin_embedder_policy(),
-              std::move(coep_reporter_for_scripts),
               ContentBrowserClient::URLLoaderFactoryType::kServiceWorkerScript);
     }
 
@@ -378,7 +335,6 @@ void EmbeddedWorkerInstance::Start(
     // instance can be started.
     factory_bundle_for_renderer = EmbeddedWorkerInstance::CreateFactoryBundle(
         rph, routing_id, origin, owner_version_->cross_origin_embedder_policy(),
-        std::move(coep_reporter_for_subresources),
         ContentBrowserClient::URLLoaderFactoryType::kServiceWorkerSubResource);
   }
 
@@ -752,8 +708,6 @@ EmbeddedWorkerInstance::CreateFactoryBundle(
     const url::Origin& origin,
     const base::Optional<network::CrossOriginEmbedderPolicy>&
         cross_origin_embedder_policy,
-    mojo::PendingRemote<network::mojom::CrossOriginEmbedderPolicyReporter>
-        coep_reporter,
     ContentBrowserClient::URLLoaderFactoryType factory_type) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   auto factory_bundle =
@@ -767,7 +721,6 @@ EmbeddedWorkerInstance::CreateFactoryBundle(
           net::IsolationInfo::Create(net::IsolationInfo::RequestType::kOther,
                                      origin, origin,
                                      net::SiteForCookies::FromOrigin(origin)),
-          std::move(coep_reporter),
           static_cast<StoragePartitionImpl*>(rph->GetStoragePartition())
               ->CreateAuthCertObserverForServiceWorker(),
           "EmbeddedWorkerInstance::CreateFactoryBundle");
@@ -849,59 +802,23 @@ EmbeddedWorkerInstance::CreateFactoryBundles() {
     return result;
   }
 
-  // Create mojo::Remote which is connected to and owns a COEP reporter.
-  mojo::PendingRemote<network::mojom::CrossOriginEmbedderPolicyReporter>
-      coep_reporter_for_devtools;
-  mojo::PendingRemote<network::mojom::CrossOriginEmbedderPolicyReporter>
-      coep_reporter_for_scripts;
-  mojo::PendingRemote<network::mojom::CrossOriginEmbedderPolicyReporter>
-      coep_reporter_for_subresources;
-
   // |cross_origin_embedder_policy| is nullopt in some unittests.
   // TODO(shimazu): Set COEP in those tests.
   if (owner_version_->cross_origin_embedder_policy()) {
-    mojo::PendingRemote<blink::mojom::ReportingObserver>
-        reporting_observer_remote;
-    owner_version_->set_reporting_observer_receiver(
-        reporting_observer_remote.InitWithNewPipeAndPassReceiver());
-
-    auto reporter = std::make_unique<CrossOriginEmbedderPolicyReporter>(
-        rph->GetStoragePartition(), owner_version_->script_url(),
-        owner_version_->cross_origin_embedder_policy()->reporting_endpoint,
-        owner_version_->cross_origin_embedder_policy()
-            ->report_only_reporting_endpoint,
-        // TODO(https://crbug.com/1147281): This is the NetworkIsolationKey of a
-        // top-level browsing context, which shouldn't be use for ServiceWorkers
-        // used in iframes.
-        net::NetworkIsolationKey::ToDoUseTopFrameOriginAsWell(
-            url::Origin::Create(owner_version_->script_url())));
-    reporter->BindObserver(std::move(reporting_observer_remote));
-    mojo::MakeSelfOwnedReceiver(std::move(reporter),
-                                coep_reporter_.BindNewPipeAndPassReceiver());
-    coep_reporter_->Clone(
-        coep_reporter_for_devtools.InitWithNewPipeAndPassReceiver());
-    coep_reporter_->Clone(
-        coep_reporter_for_scripts.InitWithNewPipeAndPassReceiver());
-    coep_reporter_->Clone(
-        coep_reporter_for_subresources.InitWithNewPipeAndPassReceiver());
-
     ServiceWorkerDevToolsManager::GetInstance()
         ->UpdateCrossOriginEmbedderPolicy(
             process_id(), worker_devtools_agent_route_id(),
-            owner_version_->cross_origin_embedder_policy().value(),
-            std::move(coep_reporter_for_devtools));
+            owner_version_->cross_origin_embedder_policy().value());
   }
 
   const url::Origin origin = url::Origin::Create(owner_version_->script_url());
   result.script_bundle = EmbeddedWorkerInstance::CreateFactoryBundle(
       rph, worker_devtools_agent_route_id(), origin,
       owner_version_->cross_origin_embedder_policy(),
-      std::move(coep_reporter_for_scripts),
       ContentBrowserClient::URLLoaderFactoryType::kServiceWorkerScript);
   result.subresource_bundle = EmbeddedWorkerInstance::CreateFactoryBundle(
       rph, worker_devtools_agent_route_id(), origin,
       owner_version_->cross_origin_embedder_policy(),
-      std::move(coep_reporter_for_subresources),
       ContentBrowserClient::URLLoaderFactoryType::kServiceWorkerSubResource);
 
   BindCacheStorageInternal();
@@ -984,7 +901,6 @@ void EmbeddedWorkerInstance::ReleaseProcess() {
   process_handle_.reset();
   lifetime_tracker_.reset();
   subresource_loader_updater_.reset();
-  coep_reporter_.reset();
   status_ = EmbeddedWorkerStatus::STOPPED;
   starting_phase_ = NOT_STARTING;
   thread_id_ = ServiceWorkerConsts::kInvalidEmbeddedWorkerThreadId;
@@ -1095,18 +1011,11 @@ void EmbeddedWorkerInstance::BindCacheStorageInternal() {
       owner_version_->cross_origin_embedder_policy().value();
 
   for (auto& receiver : pending_cache_storage_receivers_) {
-    mojo::PendingRemote<network::mojom::CrossOriginEmbedderPolicyReporter>
-        coep_reporter_remote;
-    if (coep_reporter_) {
-      coep_reporter_->Clone(
-          coep_reporter_remote.InitWithNewPipeAndPassReceiver());
-    }
-
     auto* rph = RenderProcessHost::FromID(process_id());
     if (!rph)
       return;
 
-    rph->BindCacheStorage(coep, std::move(coep_reporter_remote),
+    rph->BindCacheStorage(coep,
                           owner_version_->origin(), std::move(receiver));
   }
   pending_cache_storage_receivers_.clear();
