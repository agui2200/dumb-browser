diff --git a/chrome/browser/extensions/blocklist_state_fetcher.cc b/chrome/browser/extensions/blocklist_state_fetcher.cc
index f1a75ca84bec..d5a479238b63 100644
--- a/chrome/browser/extensions/blocklist_state_fetcher.cc
+++ b/chrome/browser/extensions/blocklist_state_fetcher.cc
@@ -8,10 +8,6 @@
 #include "base/strings/stringprintf.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "chrome/browser/browser_process.h"
-#include "chrome/browser/safe_browsing/safe_browsing_service.h"
-#include "chrome/common/safe_browsing/crx_info.pb.h"
-#include "components/safe_browsing/core/db/v4_protocol_manager_util.h"
-#include "components/safe_browsing/core/features.h"
 #include "content/public/browser/browser_thread.h"
 #include "net/base/escape.h"
 #include "net/traffic_annotation/network_traffic_annotation.h"
@@ -32,98 +28,12 @@ BlocklistStateFetcher::~BlocklistStateFetcher() {
 void BlocklistStateFetcher::Request(const std::string& id,
                                     const RequestCallback& callback) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  if (!safe_browsing_config_) {
-    if (g_browser_process && g_browser_process->safe_browsing_service()) {
-      SetSafeBrowsingConfig(
-          g_browser_process->safe_browsing_service()->GetV4ProtocolConfig());
-    } else {
-      base::ThreadTaskRunnerHandle::Get()->PostTask(
-          FROM_HERE, base::BindOnce(callback, BLOCKLISTED_UNKNOWN));
-      return;
-    }
-  }
-
-  bool request_already_sent = base::Contains(callbacks_, id);
-  callbacks_.insert(std::make_pair(id, callback));
-  if (request_already_sent)
-    return;
-
-  if (g_browser_process && g_browser_process->safe_browsing_service()) {
-    if (base::FeatureList::IsEnabled(
-            safe_browsing::kSafeBrowsingRemoveCookies)) {
-      url_loader_factory_ = g_browser_process->shared_url_loader_factory();
-    } else {
-      url_loader_factory_ =
-          g_browser_process->safe_browsing_service()->GetURLLoaderFactory();
-    }
-  }
-
-  SendRequest(id);
+  base::ThreadTaskRunnerHandle::Get()->PostTask(
+    FROM_HERE, base::BindOnce(callback, BLOCKLISTED_UNKNOWN));
 }
 
 void BlocklistStateFetcher::SendRequest(const std::string& id) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  ClientCRXListInfoRequest request;
-  request.set_id(id);
-  std::string request_str;
-  request.SerializeToString(&request_str);
-
-  GURL request_url = GURL(safe_browsing::GetReportUrl(
-      *safe_browsing_config_, "clientreport/crx-list-info"));
-  net::NetworkTrafficAnnotationTag traffic_annotation =
-      net::DefineNetworkTrafficAnnotation("extension_blacklist", R"(
-        semantics {
-          sender: "Extension Blacklist"
-          description:
-            "Chromium protects the users from malicious extensions by checking "
-            "extensions that are being installed or have been installed "
-            "against a list of known malwares. Chromium sends the identifiers "
-            "of extensions to Google and Google responds with whether it "
-            "believes each extension is malware or not. Only extensions that "
-            "match the safe browsing blacklist can trigger this request."
-          trigger:
-            "When extensions are being installed and at startup when existing "
-            "extensions are scanned."
-          data: "The identifier of the installed extension."
-          destination: GOOGLE_OWNED_SERVICE
-        }
-        policy {
-          cookies_allowed: YES
-          cookies_store: "Safe Browsing cookies store"
-          setting:
-            "Users can enable or disable this feature by toggling 'Protect you "
-            "and your device from dangerous sites' in Chromium settings under "
-            "Privacy. This feature is enabled by default."
-          chrome_policy {
-            SafeBrowsingEnabled {
-              policy_options {mode: MANDATORY}
-              SafeBrowsingEnabled: false
-            }
-          }
-        })");
-  auto resource_request = std::make_unique<network::ResourceRequest>();
-  resource_request->url = request_url;
-  resource_request->method = "POST";
-  if (base::FeatureList::IsEnabled(safe_browsing::kSafeBrowsingRemoveCookies)) {
-    resource_request->credentials_mode = network::mojom::CredentialsMode::kOmit;
-  }
-  std::unique_ptr<network::SimpleURLLoader> fetcher_ptr =
-      network::SimpleURLLoader::Create(std::move(resource_request),
-                                       traffic_annotation);
-  auto* fetcher = fetcher_ptr.get();
-  fetcher->AttachStringForUpload(request_str, "application/octet-stream");
-  requests_[fetcher] = {std::move(fetcher_ptr), id};
-  fetcher->DownloadToStringOfUnboundedSizeUntilCrashAndDie(
-      url_loader_factory_.get(),
-      base::BindOnce(&BlocklistStateFetcher::OnURLLoaderComplete,
-                     base::Unretained(this), fetcher));
-}
-
-void BlocklistStateFetcher::SetSafeBrowsingConfig(
-    const safe_browsing::V4ProtocolConfig& config) {
-  safe_browsing_config_ =
-      std::make_unique<safe_browsing::V4ProtocolConfig>(config);
 }
 
 void BlocklistStateFetcher::OnURLLoaderComplete(
@@ -161,12 +71,7 @@ void BlocklistStateFetcher::OnURLLoaderCompleteInternal(
 
   BlocklistState state;
   if (net_error == net::OK && response_code == 200) {
-    ClientCRXListInfoResponse response;
-    if (response.ParseFromString(response_body)) {
-      state = static_cast<BlocklistState>(response.verdict());
-    } else {
-      state = BLOCKLISTED_UNKNOWN;
-    }
+    state = BLOCKLISTED_UNKNOWN;
   } else {
     if (net_error != net::OK) {
       VLOG(1) << "Blocklist request for: " << id
