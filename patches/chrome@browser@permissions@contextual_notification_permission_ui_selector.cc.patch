diff --git a/chrome/browser/permissions/contextual_notification_permission_ui_selector.cc b/chrome/browser/permissions/contextual_notification_permission_ui_selector.cc
index f0e06da73f2b..c453d6f36e74 100644
--- a/chrome/browser/permissions/contextual_notification_permission_ui_selector.cc
+++ b/chrome/browser/permissions/contextual_notification_permission_ui_selector.cc
@@ -18,10 +18,8 @@
 #include "chrome/browser/permissions/crowd_deny_preload_data.h"
 #include "chrome/browser/permissions/quiet_notification_permission_ui_config.h"
 #include "chrome/browser/permissions/quiet_notification_permission_ui_state.h"
-#include "chrome/browser/safe_browsing/safe_browsing_service.h"
 #include "chrome/common/chrome_features.h"
 #include "components/permissions/permission_request.h"
-#include "components/safe_browsing/core/db/database_manager.h"
 
 namespace {
 
@@ -108,26 +106,6 @@ base::Optional<Decision> GetDecisionBasedOnSiteReputation(
   return base::nullopt;
 }
 
-// Roll the dice to decide whether to use the normal UI even when the preload
-// data indicates that quiet UI should be used. This creates a control group of
-// normal UI prompt impressions, which facilitates comparing acceptance rates,
-// better calibrating server-side logic, and detecting when the notification
-// experience on the site has improved.
-bool ShouldHoldBackQuietUI(QuietUiReason quiet_ui_reason) {
-  const double kHoldbackChance =
-      QuietNotificationPermissionUiConfig::GetCrowdDenyHoldBackChance();
-
-  // There is no hold-back when the quiet UI is shown due to abusive permission
-  // request UX, as those verdicts are not calculated based on acceptance rates.
-  if (quiet_ui_reason != QuietUiReason::kTriggeredByCrowdDeny)
-    return false;
-
-  // Avoid rolling a dice if the chance is 0.
-  const bool result = kHoldbackChance && base::RandDouble() < kHoldbackChance;
-  base::UmaHistogramBoolean("Permissions.CrowdDeny.DidHoldbackQuietUi", result);
-  return result;
-}
-
 }  // namespace
 
 ContextualNotificationPermissionUiSelector::
@@ -151,9 +129,6 @@ void ContextualNotificationPermissionUiSelector::SelectUiToUse(
 }
 
 void ContextualNotificationPermissionUiSelector::Cancel() {
-  // The computation either finishes synchronously above, or is waiting on the
-  // Safe Browsing check.
-  safe_browsing_request_.reset();
 }
 
 ContextualNotificationPermissionUiSelector::
@@ -170,40 +145,6 @@ void ContextualNotificationPermissionUiSelector::EvaluatePerSiteTriggers(
     Notify(Decision::UseNormalUiAndShowNoWarning());
     return;
   }
-
-  DCHECK(!safe_browsing_request_);
-  DCHECK(g_browser_process->safe_browsing_service());
-
-  // It is fine to use base::Unretained() here, as |safe_browsing_request_|
-  // guarantees not to fire the callback after its destruction.
-  safe_browsing_request_.emplace(
-      g_browser_process->safe_browsing_service()->database_manager(),
-      base::DefaultClock::GetInstance(), origin,
-      base::BindOnce(&ContextualNotificationPermissionUiSelector::
-                         OnSafeBrowsingVerdictReceived,
-                     base::Unretained(this), *decision));
-}
-
-void ContextualNotificationPermissionUiSelector::OnSafeBrowsingVerdictReceived(
-    Decision candidate_decision,
-    CrowdDenySafeBrowsingRequest::Verdict verdict) {
-  DCHECK(safe_browsing_request_);
-  DCHECK(callback_);
-
-  safe_browsing_request_.reset();
-
-  switch (verdict) {
-    case CrowdDenySafeBrowsingRequest::Verdict::kAcceptable:
-      Notify(Decision::UseNormalUiAndShowNoWarning());
-      break;
-    case CrowdDenySafeBrowsingRequest::Verdict::kUnacceptable:
-      if (candidate_decision.quiet_ui_reason &&
-          ShouldHoldBackQuietUI(*(candidate_decision.quiet_ui_reason))) {
-        candidate_decision.quiet_ui_reason.reset();
-      }
-      Notify(candidate_decision);
-      break;
-  }
 }
 
 void ContextualNotificationPermissionUiSelector::Notify(
