--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -2599,6 +2599,9 @@ const FeatureEntry kFeatureEntries[] = {
      flag_descriptions::kLockScreenNotificationDescription, kOsCrOS,
      FEATURE_VALUE_TYPE(ash::features::kLockScreenNotifications)},
 #endif  // OS_CHROMEOS
+    {"enable-tab-audio-muting", flag_descriptions::kTabAudioMutingName,
+     flag_descriptions::kTabAudioMutingDescription, kOsDesktop,
+     SINGLE_VALUE_TYPE(switches::kEnableTabAudioMuting)},
     {"reduced-referrer-granularity",
      flag_descriptions::kReducedReferrerGranularityName,
      flag_descriptions::kReducedReferrerGranularityDescription, kOsAll,
--- a/chrome/browser/content_settings/sound_content_setting_observer.cc
+++ b/chrome/browser/content_settings/sound_content_setting_observer.cc
@@ -132,6 +132,10 @@ void SoundContentSettingObserver::MuteOr

   TabMutedReason reason = chrome::GetTabAudioMutedReason(web_contents());

+  // Do not unmute if we're muted due to audio indicator.
+  if (!mute && reason == TabMutedReason::AUDIO_INDICATOR)
+    return;
+
   // Do not override the decisions of an extension.
   if (reason == TabMutedReason::EXTENSION)
     return;
--- a/chrome/browser/extensions/api/tabs/tabs_api.cc
+++ b/chrome/browser/extensions/api/tabs/tabs_api.cc
@@ -56,6 +56,7 @@
 #include "chrome/browser/ui/tabs/tab_utils.h"
 #include "chrome/browser/ui/window_sizer/window_sizer.h"
 #include "chrome/browser/web_applications/components/web_app_helpers.h"
+#include "chrome/common/chrome_switches.h"
 #include "chrome/common/extensions/api/tabs.h"
 #include "chrome/common/extensions/api/windows.h"
 #include "chrome/common/extensions/extension_constants.h"
--- a/chrome/browser/extensions/api/tabs/tabs_constants.cc
+++ b/chrome/browser/extensions/api/tabs/tabs_constants.cc
@@ -104,6 +104,8 @@ const char kSupportedInWindowsOnlyError[
 const char kInvalidWindowTypeError[] = "Invalid value for type";
 const char kInvalidWindowStateError[] = "Invalid value for state";
 const char kScreenshotsDisabled[] = "Taking screenshots has been disabled";
+const char kCannotUpdateMuteDisabled[] =
+    "Failed to update mute state for tab *, --* must be enabled";
 const char kCannotUpdateMuteCaptured[] =
     "Cannot update mute state for tab *, tab has audio or video currently "
     "being captured";
--- a/chrome/browser/extensions/api/tabs/tabs_constants.h
+++ b/chrome/browser/extensions/api/tabs/tabs_constants.h
@@ -101,6 +101,7 @@ extern const char kSupportedInWindowsOnl
 extern const char kInvalidWindowTypeError[];
 extern const char kInvalidWindowStateError[];
 extern const char kScreenshotsDisabled[];
+extern const char kCannotUpdateMuteDisabled[];
 extern const char kCannotUpdateMuteCaptured[];
 extern const char kCannotDetermineLanguageOfUnloadedTab[];
 extern const char kMissingLockWindowFullscreenPrivatePermission[];
--- a/chrome/browser/extensions/extension_tab_util.cc
+++ b/chrome/browser/extensions/extension_tab_util.cc
@@ -546,11 +546,12 @@ ExtensionTabUtil::CreateWindowValueForEx
 std::unique_ptr<api::tabs::MutedInfo> ExtensionTabUtil::CreateMutedInfo(
     content::WebContents* contents) {
   DCHECK(contents);
-  auto info = std::make_unique<api::tabs::MutedInfo>();
+  std::unique_ptr<api::tabs::MutedInfo> info(new api::tabs::MutedInfo);
   info->muted = contents->IsAudioMuted();
   switch (chrome::GetTabAudioMutedReason(contents)) {
     case TabMutedReason::NONE:
       break;
+    case TabMutedReason::AUDIO_INDICATOR:
     case TabMutedReason::CONTENT_SETTING:
     case TabMutedReason::CONTENT_SETTING_CHROME:
     case TabMutedReason::CONTEXT_MENU:
--- a/chrome/browser/flag_descriptions.cc
+++ b/chrome/browser/flag_descriptions.cc
@@ -2067,6 +2067,12 @@ const char kSystemKeyboardLockDescriptio
     "keyboard shortcuts and have the events routed directly to the website "
     "when in fullscreen mode.";

+const char kTabAudioMutingName[] = "Tab audio muting UI control";
+const char kTabAudioMutingDescription[] =
+    "When enabled, the audio indicators in the tab strip double as tab audio "
+    "mute controls. This also adds commands in the tab context menu for "
+    "quickly muting multiple selected tabs.";
+
 const char kSystemTrayMicGainName[] = "Modify mic gain in the system tray";
 const char kSystemTrayMicGainDescription[] =
     "Enables mic gain settings in the system tray audio "
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -1182,6 +1182,9 @@ extern const char kStrictOriginIsolation
 extern const char kSystemKeyboardLockName[];
 extern const char kSystemKeyboardLockDescription[];

+extern const char kTabAudioMutingName[];
+extern const char kTabAudioMutingDescription[];
+
 extern const char kSuggestedContentToggleName[];
 extern const char kSuggestedContentToggleDescription[];

--- a/chrome/browser/ui/BUILD.gn
+++ b/chrome/browser/ui/BUILD.gn
@@ -3677,8 +3677,8 @@ static_library("ui") {
       "views/tab_search/tab_search_bubble_view.h",
       "views/tab_sharing/tab_sharing_ui_views.cc",
       "views/tab_sharing/tab_sharing_ui_views.h",
-      "views/tabs/alert_indicator.cc",
-      "views/tabs/alert_indicator.h",
+      "views/tabs/alert_indicator_button.cc",
+      "views/tabs/alert_indicator_button.h",
       "views/tabs/browser_tab_strip_controller.cc",
       "views/tabs/browser_tab_strip_controller.h",
       "views/tabs/color_picker_view.cc",
--- a/chrome/browser/ui/tabs/tab_utils.h
+++ b/chrome/browser/ui/tabs/tab_utils.h
@@ -35,6 +35,7 @@ enum class TabAlertState {

 enum class TabMutedReason {
   NONE,                    // The tab has never been muted or unmuted.
+  AUDIO_INDICATOR,         // Mute toggled via tab-strip audio icon.
   CONTEXT_MENU,            // Mute/Unmute chosen from tab context menu.
   EXTENSION,               // Mute state changed via extension API.
   CONTENT_SETTING,         // The sound content setting was set to BLOCK.
--- a/chrome/browser/ui/views/tabs/alert_indicator.cc
+++ b/chrome/browser/ui/views/tabs/alert_indicator.cc
@@ -252,4 +252,4 @@ void AlertIndicator::ResetImage(TabAlert
   SkColor color = parent_tab_->GetAlertIndicatorColor(state);
   gfx::ImageSkia image = GetTabAlertIndicatorImage(state, color).AsImageSkia();
   SetImage(&image);
-}
+}
\ No newline at end of file
--- a/chrome/browser/ui/views/tabs/browser_tab_strip_controller.cc
+++ b/chrome/browser/ui/views/tabs/browser_tab_strip_controller.cc
@@ -347,6 +347,12 @@ void BrowserTabStripController::CloseTab
                              TabStripModel::CLOSE_CREATE_HISTORICAL_TAB);
 }

+void BrowserTabStripController::ToggleTabAudioMute(int model_index) {
+  content::WebContents* const contents = model_->GetWebContentsAt(model_index);
+  chrome::SetTabAudioMuted(contents, !contents->IsAudioMuted(),
+                           TabMutedReason::AUDIO_INDICATOR, std::string());
+}
+
 void BrowserTabStripController::AddTabToGroup(
     int model_index,
     const tab_groups::TabGroupId& group) {
--- a/chrome/browser/ui/views/tabs/browser_tab_strip_controller.h
+++ b/chrome/browser/ui/views/tabs/browser_tab_strip_controller.h
@@ -70,6 +70,7 @@ class BrowserTabStripController : public
   void AddSelectionFromAnchorTo(int model_index) override;
   bool BeforeCloseTab(int model_index, CloseTabSource source) override;
   void CloseTab(int model_index) override;
+  void ToggleTabAudioMute(int model_index) override;
   void AddTabToGroup(int model_index,
                      const tab_groups::TabGroupId& group) override;
   void RemoveTabFromGroup(int model_index) override;
--- a/chrome/browser/ui/views/tabs/fake_base_tab_strip_controller.cc
+++ b/chrome/browser/ui/views/tabs/fake_base_tab_strip_controller.cc
@@ -205,6 +205,9 @@ void FakeBaseTabStripController::CloseTa
   RemoveTab(index);
 }

+void FakeBaseTabStripController::ToggleTabAudioMute(int index) {
+}
+
 void FakeBaseTabStripController::ShowContextMenuForTab(
     Tab* tab,
     const gfx::Point& p,
--- a/chrome/browser/ui/views/tabs/fake_base_tab_strip_controller.h
+++ b/chrome/browser/ui/views/tabs/fake_base_tab_strip_controller.h
@@ -46,6 +46,7 @@ class FakeBaseTabStripController : publi
   void AddSelectionFromAnchorTo(int index) override;
   bool BeforeCloseTab(int index, CloseTabSource source) override;
   void CloseTab(int index) override;
+  void ToggleTabAudioMute(int index) override;
   void MoveTab(int from_index, int to_index) override;
   void MoveGroup(const tab_groups::TabGroupId&, int to_index) override;
   bool ToggleTabGroupCollapsedState(const tab_groups::TabGroupId group,
--- a/chrome/browser/ui/views/tabs/tab.cc
+++ b/chrome/browser/ui/views/tabs/tab.cc
@@ -34,7 +34,7 @@
 #include "chrome/browser/ui/view_ids.h"
 #include "chrome/browser/ui/views/chrome_layout_provider.h"
 #include "chrome/browser/ui/views/frame/browser_view.h"
-#include "chrome/browser/ui/views/tabs/alert_indicator.h"
+#include "chrome/browser/ui/views/tabs/alert_indicator_button.h"
 #include "chrome/browser/ui/views/tabs/browser_tab_strip_controller.h"
 #include "chrome/browser/ui/views/tabs/tab_close_button.h"
 #include "chrome/browser/ui/views/tabs/tab_controller.h"
@@ -212,8 +212,8 @@ Tab::Tab(TabController* controller)
   icon_ = new TabIcon;
   AddChildView(icon_);

-  alert_indicator_ = new AlertIndicator(this);
-  AddChildView(alert_indicator_);
+  alert_indicator_button_ = new AlertIndicatorButton(this);
+  AddChildView(alert_indicator_button_);

   // Unretained is safe here because this class outlives its close button, and
   // the controller outlives this Tab.
@@ -256,14 +256,6 @@ void Tab::AnimationProgressed(const gfx:
 }

 void Tab::ButtonPressed(views::Button* sender, const ui::Event& event) {
-  if (!alert_indicator_ || !alert_indicator_->GetVisible())
-    base::RecordAction(UserMetricsAction("CloseTab_NoAlertIndicator"));
-  else if (GetAlertStateToShow(data_.alert_state) ==
-           TabAlertState::AUDIO_PLAYING)
-    base::RecordAction(UserMetricsAction("CloseTab_AudioIndicator"));
-  else
-    base::RecordAction(UserMetricsAction("CloseTab_RecordingIndicator"));
-
   const CloseTabSource source = (event.type() == ui::ET_MOUSE_RELEASED &&
                                  !(event.flags() & ui::EF_FROM_TOUCH))
                                     ? CLOSE_TAB_FROM_MOUSE
@@ -362,7 +354,7 @@ void Tab::Layout() {
       if (extra_alert_indicator_padding_)
         right -= ui::TouchUiController::Get()->touch_ui() ? 8 : 6;
     }
-    const gfx::Size image_size = alert_indicator_->GetPreferredSize();
+    const gfx::Size image_size = alert_indicator_button_->GetPreferredSize();
     gfx::Rect bounds(
         std::max(contents_rect.x(), right - image_size.width()),
         contents_rect.y() + Center(contents_rect.height(), image_size.height()),
@@ -374,9 +366,9 @@ void Tab::Layout() {
     } else {
       MaybeAdjustLeftForPinnedTab(&bounds, bounds.width());
     }
-    alert_indicator_->SetBoundsRect(bounds);
+    alert_indicator_button_->SetBoundsRect(bounds);
   }
-  alert_indicator_->SetVisible(showing_alert_indicator_);
+  alert_indicator_button_->SetVisible(showing_alert_indicator_);

   // Size the title to fill the remaining width and use all available height.
   bool show_title = ShouldRenderAsNormalTab();
@@ -394,7 +386,7 @@ void Tab::Layout() {
     }
     int title_right = contents_rect.right();
     if (showing_alert_indicator_) {
-      title_right = alert_indicator_->x() - after_title_padding;
+      title_right = alert_indicator_button_->x() - after_title_padding;
     } else if (showing_close_button_) {
       // Allow the title to overlay the close button's empty border padding.
       title_right = close_x - after_title_padding;
@@ -791,10 +783,23 @@ bool Tab::IsActive() const {
   return controller_->IsActiveTab(this);
 }

+int Tab::GetWidthOfLargestSelectableRegion() const {
+  // Assume the entire region to the left of the alert indicator and/or close
+  // buttons is available for click-to-select.  If neither are visible, the
+  // entire tab region is available.
+  const int indicator_left = alert_indicator_button_->GetVisible()
+                                 ? alert_indicator_button_->x()
+                                 : width();
+  const int close_button_left =
+      close_button_->GetVisible() ? close_button_->x() : width();
+  return std::min(indicator_left, close_button_left);
+}
+
 void Tab::ActiveStateChanged() {
   UpdateTabIconNeedsAttentionBlocked();
   UpdateForegroundColors();
   title_->SetFontList(tab_style_->GetFontList());
+  alert_indicator_button_->UpdateEnabledForMuteToggle();
   Layout();
 }

@@ -842,7 +847,7 @@ void Tab::SetData(TabRendererData data)
   const auto new_alert_state = GetAlertStateToShow(data_.alert_state);
   const auto old_alert_state = GetAlertStateToShow(old.alert_state);
   if (new_alert_state != old_alert_state)
-    alert_indicator_->TransitionToAlertState(new_alert_state);
+    alert_indicator_button_->TransitionToAlertState(new_alert_state);
   if (old.pinned != data_.pinned)
     showing_alert_indicator_ = false;

@@ -933,7 +938,7 @@ void Tab::UpdateIconVisibility() {

   const bool has_favicon = data().show_icon;
   const bool has_alert_icon =
-      (alert_indicator_ ? alert_indicator_->showing_alert_state()
+      (alert_indicator_button_ ? alert_indicator_button_->showing_alert_state()
                         : GetAlertStateToShow(data().alert_state))
           .has_value();

@@ -950,7 +955,7 @@ void Tab::UpdateIconVisibility() {

   const bool touch_ui = ui::TouchUiController::Get()->touch_ui();
   const int favicon_width = gfx::kFaviconSize;
-  const int alert_icon_width = alert_indicator_->GetPreferredSize().width();
+  const int alert_icon_width = alert_indicator_button_->GetPreferredSize().width();
   // In case of touch optimized UI, the close button has an extra padding on the
   // left that needs to be considered.
   const int close_button_width =
@@ -1044,7 +1049,7 @@ void Tab::UpdateForegroundColors() {

   if (foreground_color_ != colors.foreground_color) {
     foreground_color_ = colors.foreground_color;
-    alert_indicator_->OnParentTabButtonColorChanged();
+    alert_indicator_button_->OnParentTabButtonColorChanged();
   }

   SchedulePaint();
--- a/chrome/browser/ui/views/tabs/tab.h
+++ b/chrome/browser/ui/views/tabs/tab.h
@@ -27,7 +27,7 @@
 #include "ui/views/masked_targeter_delegate.h"
 #include "ui/views/view_observer.h"

-class AlertIndicator;
+class AlertIndicatorButton;
 class TabCloseButton;
 class TabController;
 class TabIcon;
@@ -120,6 +120,10 @@ class Tab : public gfx::AnimationDelegat
   // Returns true if this tab is the active tab.
   bool IsActive() const;

+  // Returns the width of the largest part of the tab that is available for the
+  // user to click to select/activate the tab.
+  int GetWidthOfLargestSelectableRegion() const;
+
   // Notifies the AlertIndicatorButton that the active state of this tab has
   // changed.
   void ActiveStateChanged();
@@ -225,7 +229,7 @@ class Tab : public gfx::AnimationDelegat
   bool closing_ = false;

   TabIcon* icon_ = nullptr;
-  AlertIndicator* alert_indicator_ = nullptr;
+  AlertIndicatorButton* alert_indicator_button_ = nullptr;
   TabCloseButton* close_button_ = nullptr;

   views::Label* title_;
--- a/chrome/browser/ui/views/tabs/tab_controller.h
+++ b/chrome/browser/ui/views/tabs/tab_controller.h
@@ -58,6 +58,9 @@ class TabController {
   // Closes the tab.
   virtual void CloseTab(Tab* tab, CloseTabSource source) = 0;

+  // Toggles whether tab-wide audio muting is active.
+  virtual void ToggleTabAudioMute(Tab* tab) = 0;
+
   // Attempts to shift the specified tab to the right by one index.
   virtual void ShiftTabRight(Tab* tab) = 0;

--- a/chrome/browser/ui/views/tabs/tab_strip.cc
+++ b/chrome/browser/ui/views/tabs/tab_strip.cc
@@ -2815,6 +2815,12 @@ void TabStrip::CloseTabInternal(int mode
   controller_->CloseTab(model_index);
 }

+void TabStrip::ToggleTabAudioMute(Tab* tab) {
+  int model_index = GetModelIndexOf(tab);
+  if (IsValidModelIndex(model_index))
+    controller_->ToggleTabAudioMute(model_index);
+}
+
 void TabStrip::RemoveTabFromViewModel(int index) {
   Tab* closing_tab = tab_at(index);
   bool closing_tab_was_active = closing_tab->IsActive();
--- a/chrome/browser/ui/views/tabs/tab_strip.h
+++ b/chrome/browser/ui/views/tabs/tab_strip.h
@@ -277,6 +277,7 @@ class TabStrip : public views::Accessibl
   void ToggleSelected(Tab* tab) override;
   void AddSelectionFromAnchorTo(Tab* tab) override;
   void CloseTab(Tab* tab, CloseTabSource source) override;
+  void ToggleTabAudioMute(Tab* tab) override;
   void ShiftTabLeft(Tab* tab) override;
   void ShiftTabRight(Tab* tab) override;
   void MoveTabFirst(Tab* tab) override;
--- a/chrome/browser/ui/views/tabs/tab_strip_controller.h
+++ b/chrome/browser/ui/views/tabs/tab_strip_controller.h
@@ -82,6 +82,9 @@ class TabStripController {
   // Closes the tab at the specified index in the model.
   virtual void CloseTab(int index) = 0;

+  // Toggles audio muting for the tab at the specified index in the model.
+  virtual void ToggleTabAudioMute(int index) = 0;
+
   // Adds a tab to an existing tab group.
   virtual void AddTabToGroup(int model_index,
                              const tab_groups::TabGroupId& group) = 0;
--- a/chrome/common/chrome_switches.cc
+++ b/chrome/common/chrome_switches.cc
@@ -301,6 +301,9 @@ const char kEnableNetBenchmarking[]
 const char kEnablePotentiallyAnnoyingSecurityFeatures[] =
     "enable-potentially-annoying-security-features";

+// Enables user control over muting tab audio from the tab strip.
+const char kEnableTabAudioMuting[]  = "enable-tab-audio-muting";
+
 // Name of the command line flag to force content verification to be on in one
 // of various modes.
 const char kExtensionContentVerification[] = "extension-content-verification";
--- a/chrome/common/chrome_switches.h
+++ b/chrome/common/chrome_switches.h
@@ -96,6 +96,7 @@ extern const char kEnableExtensionActivi
 extern const char kEnableNaCl[];
 extern const char kEnableNetBenchmarking[];
 extern const char kEnablePotentiallyAnnoyingSecurityFeatures[];
+extern const char kEnableTabAudioMuting[];
 extern const char kExtensionContentVerification[];
 extern const char kExtensionContentVerificationBootstrap[];
 extern const char kExtensionContentVerificationEnforce[];
--- a/chromecast/browser/extensions/api/tabs/tabs_constants.cc
+++ b/chromecast/browser/extensions/api/tabs/tabs_constants.cc
@@ -110,6 +110,8 @@ const char kSupportedInWindowsOnlyError[
 const char kInvalidWindowTypeError[] = "Invalid value for type";
 const char kInvalidWindowStateError[] = "Invalid value for state";
 const char kScreenshotsDisabled[] = "Taking screenshots has been disabled";
+const char kCannotUpdateMuteDisabled[] =
+    "Failed to update mute state for tab *, --* must be enabled";
 const char kCannotUpdateMuteCaptured[] =
     "Cannot update mute state for tab *, tab has audio or video currently "
     "being captured";
--- a/chromecast/browser/extensions/api/tabs/tabs_constants.h
+++ b/chromecast/browser/extensions/api/tabs/tabs_constants.h
@@ -102,6 +102,7 @@ extern const char kSupportedInWindowsOnl
 extern const char kInvalidWindowTypeError[];
 extern const char kInvalidWindowStateError[];
 extern const char kScreenshotsDisabled[];
+extern const char kCannotUpdateMuteDisabled[];
 extern const char kCannotUpdateMuteCaptured[];
 extern const char kCannotDetermineLanguageOfUnloadedTab[];
 extern const char kMissingLockWindowFullscreenPrivatePermission[];
--- /dev/null
+++ b/chrome/browser/ui/views/tabs/alert_indicator_button.h
@@ -0,0 +1,126 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_VIEWS_TABS_ALERT_INDICATOR_BUTTON_H_
+#define CHROME_BROWSER_UI_VIEWS_TABS_ALERT_INDICATOR_BUTTON_H_
+
+#include <memory>
+
+#include "base/macros.h"
+#include "base/optional.h"
+#include "chrome/browser/ui/tabs/tab_utils.h"
+#include "ui/views/controls/button/image_button.h"
+#include "ui/views/view_targeter_delegate.h"
+
+class Tab;
+
+namespace base {
+class OneShotTimer;
+}
+
+namespace gfx {
+class Animation;
+class AnimationDelegate;
+}
+
+// This is an ImageButton subclass that serves as both the alert indicator icon
+// (audio, tab capture, etc.), and as a mute button.  It is meant to only be
+// used as a child view of Tab.
+//
+// When the indicator is transitioned to the audio playing or muting state, the
+// button functionality is enabled and begins handling mouse events.  Otherwise,
+// this view behaves like an image and all mouse events will be handled by the
+// Tab (its parent View).
+class AlertIndicatorButton : public views::ImageButton,
+                             public views::ViewTargeterDelegate {
+ public:
+  // The AlertIndicatorButton's class name.
+  static const char kViewClassName[];
+
+  explicit AlertIndicatorButton(Tab* parent_tab);
+  ~AlertIndicatorButton() override;
+
+  // Returns the current TabAlertState except, while the indicator image is
+  // fading out, returns the prior TabAlertState.
+  base::Optional<TabAlertState> showing_alert_state() const { return showing_alert_state_; }
+
+  // Calls ResetImages(), starts fade animations, and activates/deactivates
+  // button functionality as appropriate.
+  void TransitionToAlertState(base::Optional<TabAlertState> next_state);
+
+  // Determines whether the AlertIndicatorButton will be clickable for toggling
+  // muting.  This should be called whenever the active/inactive state of a tab
+  // has changed.  Internally, TransitionToAlertState() and OnBoundsChanged()
+  // calls this when the TabAlertState or the bounds have changed.
+  void UpdateEnabledForMuteToggle();
+
+  // Called when the parent tab's button color changes.  Determines whether
+  // ResetImages() needs to be called.
+  void OnParentTabButtonColorChanged();
+
+ protected:
+  // views::View:
+  const char* GetClassName() const override;
+  View* GetTooltipHandlerForPoint(const gfx::Point& point) override;
+  bool OnMousePressed(const ui::MouseEvent& event) override;
+  bool OnMouseDragged(const ui::MouseEvent& event) override;
+  void OnMouseEntered(const ui::MouseEvent& event) override;
+  void OnMouseExited(const ui::MouseEvent& event) override;
+  void OnMouseMoved(const ui::MouseEvent& event) override;
+  void OnBoundsChanged(const gfx::Rect& previous_bounds) override;
+
+  // views::ViewTargeterDelegate
+  bool DoesIntersectRect(const View* target,
+                         const gfx::Rect& rect) const override;
+
+  // views::Button:
+  void NotifyClick(const ui::Event& event) override;
+
+  // views::Button:
+  bool IsTriggerableEvent(const ui::Event& event) override;
+  void PaintButtonContents(gfx::Canvas* canvas) override;
+
+  // views::ImageButton:
+  gfx::ImageSkia GetImageToPaint() override;
+
+ private:
+  friend class AlertIndicatorButtonTest;
+  friend class TabTest;
+  class FadeAnimationDelegate;
+
+  // Returns the tab (parent view) of this AlertIndicatorButton.
+  Tab* GetTab() const;
+
+  // Resets the images to display on the button to reflect |state| and the
+  // parent tab's button color.  Should be called when either of these changes.
+  void ResetImages(base::Optional<TabAlertState> state);
+
+  // Enters a temporary "dormant period" where this AlertIndicatorButton will
+  // not trigger on clicks.  The user is provided a visual affordance during
+  // this period.  Sets a timer to call ExitDormantPeriod().
+  void EnterDormantPeriod();
+
+  // Leaves the "dormant period," allowing clicks to once again trigger an
+  // enabled AlertIndicatorButton.
+  void ExitDormantPeriod();
+
+  bool is_dormant() const { return !!wake_up_timer_; }
+
+  Tab* const parent_tab_;
+
+  base::Optional<TabAlertState> alert_state_;
+
+  // Alert indicator fade-in/out animation (i.e., only on show/hide, not a
+  // continuous animation).
+  std::unique_ptr<gfx::AnimationDelegate> fade_animation_delegate_;
+  std::unique_ptr<gfx::Animation> fade_animation_;
+  base::Optional<TabAlertState> showing_alert_state_;
+
+  // Created on-demand, this fires to exit the "dormant period."
+  std::unique_ptr<base::OneShotTimer> wake_up_timer_;
+
+  DISALLOW_COPY_AND_ASSIGN(AlertIndicatorButton);
+};
+
+#endif  // CHROME_BROWSER_UI_VIEWS_TABS_ALERT_INDICATOR_BUTTON_H_
--- /dev/null
+++ b/chrome/browser/ui/views/tabs/alert_indicator_button.cc
@@ -0,0 +1,478 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/tabs/alert_indicator_button.h"
+
+#include <utility>
+
+#include "chrome/app/vector_icons/vector_icons.h"
+#include "chrome/browser/ui/layout_constants.h"
+#include "chrome/browser/ui/tabs/tab_utils.h"
+#include "chrome/browser/ui/views/tabs/tab.h"
+#include "chrome/browser/ui/views/tabs/tab_controller.h"
+#include "chrome/common/chrome_switches.h"
+#include "components/vector_icons/vector_icons.h"
+#include "ui/base/pointer/touch_ui_controller.h"
+#include "ui/gfx/animation/multi_animation.h"
+#include "ui/gfx/canvas.h"
+#include "ui/gfx/image/image.h"
+#include "ui/gfx/paint_vector_icon.h"
+#include "ui/views/animation/animation_delegate_views.h"
+#include "ui/views/metrics.h"
+
+namespace {
+
+// The minimum required click-to-select area of an inactive Tab before allowing
+// the click-to-mute functionality to be enabled.  These values are in terms of
+// some percentage of the AlertIndicatorButton's width.  See comments in
+// UpdateEnabledForMuteToggle().
+const int kMinMouseSelectableAreaPercent = 250;
+const int kMinGestureSelectableAreaPercent = 400;
+
+// Fade-in/out duration for the tab indicator animations.  Fade-in is quick to
+// immediately notify the user.  Fade-out is more gradual, so that the user has
+// a chance of finding a tab that has quickly "blipped" on and off.
+constexpr auto kIndicatorFadeInDuration =
+    base::TimeDelta::FromMilliseconds(200);
+constexpr auto kIndicatorFadeOutDuration =
+    base::TimeDelta::FromMilliseconds(1000);
+
+// Interval between frame updates of the tab indicator animations.  This is not
+// the usual 60 FPS because a trade-off must be made between tab UI animation
+// smoothness and media recording/playback performance on low-end hardware.
+constexpr base::TimeDelta kIndicatorFrameInterval =
+    base::TimeDelta::FromMilliseconds(50);  // 20 FPS
+
+// Returns true if either Shift or Control are being held down.  In this case,
+// mouse events are delegated to the Tab, to perform tab selection in the tab
+// strip instead.
+bool IsShiftOrControlDown(const ui::Event& event) {
+  return (event.flags() & (ui::EF_SHIFT_DOWN | ui::EF_CONTROL_DOWN)) != 0;
+}
+
+// Animation that throbs in (towards 1.0) and out (towards 0.0), and ends in the
+// "in" state.
+class TabRecordingIndicatorAnimation : public gfx::MultiAnimation {
+ public:
+  TabRecordingIndicatorAnimation(const gfx::MultiAnimation::Parts& parts,
+                                 const base::TimeDelta interval)
+      : MultiAnimation(parts, interval) {}
+  ~TabRecordingIndicatorAnimation() override = default;
+
+  // Overridden to provide alternating "towards in" and "towards out" behavior.
+  double GetCurrentValue() const override;
+
+  static std::unique_ptr<TabRecordingIndicatorAnimation> Create();
+};
+
+double TabRecordingIndicatorAnimation::GetCurrentValue() const {
+  return current_part_index() % 2 ? 1.0 - MultiAnimation::GetCurrentValue()
+                                  : MultiAnimation::GetCurrentValue();
+}
+
+std::unique_ptr<TabRecordingIndicatorAnimation>
+TabRecordingIndicatorAnimation::Create() {
+  // Number of times to "toggle throb" the recording and tab capture indicators
+  // when they first appear.
+  constexpr size_t kCaptureIndicatorThrobCycles = 5;
+
+  MultiAnimation::Parts parts;
+  static_assert(
+      kCaptureIndicatorThrobCycles % 2 != 0,
+      "odd number of cycles required so animation finishes in showing state");
+  for (size_t i = 0; i < kCaptureIndicatorThrobCycles; ++i) {
+    parts.push_back(MultiAnimation::Part(
+        i % 2 ? kIndicatorFadeOutDuration : kIndicatorFadeInDuration,
+        gfx::Tween::EASE_IN));
+  }
+
+  auto animation = std::make_unique<TabRecordingIndicatorAnimation>(
+      parts, kIndicatorFrameInterval);
+  animation->set_continuous(false);
+  return animation;
+}
+
+// Returns a non-continuous Animation that performs a fade-in or fade-out
+// appropriate for the given |next_alert_state|.  This is used by the tab alert
+// indicator to alert the user that recording, tab capture, or audio playback
+// has started/stopped.
+std::unique_ptr<gfx::Animation> CreateTabAlertIndicatorFadeAnimation(
+    base::Optional<TabAlertState> alert_state) {
+  if (alert_state == TabAlertState::MEDIA_RECORDING ||
+      alert_state == TabAlertState::TAB_CAPTURING ||
+      alert_state == TabAlertState::DESKTOP_CAPTURING) {
+    return TabRecordingIndicatorAnimation::Create();
+  }
+
+  // Note: While it seems silly to use a one-part MultiAnimation, it's the only
+  // gfx::Animation implementation that lets us control the frame interval.
+  gfx::MultiAnimation::Parts parts;
+  const bool is_for_fade_in = (alert_state.has_value());
+  parts.push_back(gfx::MultiAnimation::Part(
+      is_for_fade_in ? kIndicatorFadeInDuration : kIndicatorFadeOutDuration,
+      gfx::Tween::EASE_IN));
+  auto animation =
+      std::make_unique<gfx::MultiAnimation>(parts, kIndicatorFrameInterval);
+  animation->set_continuous(false);
+  return std::move(animation);
+}
+
+// Returns a cached image, to be shown by the alert indicator for the given
+// |alert_state|.  Uses the global ui::ResourceBundle shared instance.
+gfx::Image GetTabAlertIndicatorImage(TabAlertState alert_state,
+                                     SkColor button_color) {
+  const gfx::VectorIcon* icon = nullptr;
+  int image_width = GetLayoutConstant(TAB_ALERT_INDICATOR_ICON_WIDTH);
+  const bool touch_ui = ui::TouchUiController::Get()->touch_ui();
+  switch (alert_state) {
+    case TabAlertState::AUDIO_PLAYING:
+      icon = touch_ui ? &kTabAudioRoundedIcon : &kTabAudioIcon;
+      break;
+    case TabAlertState::AUDIO_MUTING:
+      icon = touch_ui ? &kTabAudioMutingRoundedIcon : &kTabAudioMutingIcon;
+      break;
+    case TabAlertState::MEDIA_RECORDING:
+    case TabAlertState::DESKTOP_CAPTURING:
+      icon = &kTabMediaRecordingIcon;
+      break;
+    case TabAlertState::TAB_CAPTURING:
+      icon =
+          touch_ui ? &kTabMediaCapturingWithArrowIcon : &kTabMediaCapturingIcon;
+      // Tab capturing and presenting icon uses a different width compared to
+      // the other tab alert indicator icons.
+      image_width = GetLayoutConstant(TAB_ALERT_INDICATOR_CAPTURE_ICON_WIDTH);
+      break;
+    case TabAlertState::BLUETOOTH_CONNECTED:
+      icon = &kTabBluetoothConnectedIcon;
+      break;
+    case TabAlertState::USB_CONNECTED:
+      icon = &kTabUsbConnectedIcon;
+      break;
+    case TabAlertState::HID_CONNECTED:
+      icon = &vector_icons::kVideogameAssetIcon;
+      break;
+    case TabAlertState::SERIAL_CONNECTED:
+      // TODO(https://crbug.com/917204): This icon is too large to fit properly
+      // as a tab indicator and should be replaced.
+      icon = &vector_icons::kSerialPortIcon;
+      break;
+    case TabAlertState::PIP_PLAYING:
+      icon = &kPictureInPictureAltIcon;
+      break;
+    case TabAlertState::VR_PRESENTING_IN_HEADSET:
+      icon = &vector_icons::kVrHeadsetIcon;
+      break;
+  }
+  DCHECK(icon);
+  return gfx::Image(gfx::CreateVectorIcon(*icon, image_width, button_color));
+}
+
+gfx::Image GetTabAlertIndicatorAffordanceImage(TabAlertState alert_state,
+                                               SkColor button_color) {
+  switch (alert_state) {
+    case TabAlertState::AUDIO_PLAYING:
+      return GetTabAlertIndicatorImage(TabAlertState::AUDIO_MUTING,
+                                       button_color);
+    case TabAlertState::AUDIO_MUTING:
+      return GetTabAlertIndicatorImage(TabAlertState::AUDIO_PLAYING,
+                                       button_color);
+    case TabAlertState::MEDIA_RECORDING:
+    case TabAlertState::TAB_CAPTURING:
+    case TabAlertState::BLUETOOTH_CONNECTED:
+    case TabAlertState::USB_CONNECTED:
+    case TabAlertState::PIP_PLAYING:
+    case TabAlertState::DESKTOP_CAPTURING:
+    case TabAlertState::HID_CONNECTED:
+    case TabAlertState::SERIAL_CONNECTED:
+    case TabAlertState::VR_PRESENTING_IN_HEADSET:
+      return GetTabAlertIndicatorImage(alert_state, button_color);
+  }
+  NOTREACHED();
+  return GetTabAlertIndicatorImage(alert_state, button_color);
+}
+
+bool AreExperimentalMuteControlsEnabled() {
+  return base::CommandLine::ForCurrentProcess()->HasSwitch(
+      switches::kEnableTabAudioMuting);
+}
+
+}  // namespace
+
+const char AlertIndicatorButton::kViewClassName[] = "AlertIndicatorButton";
+
+class AlertIndicatorButton::FadeAnimationDelegate
+    : public gfx::AnimationDelegate {
+ public:
+  explicit FadeAnimationDelegate(AlertIndicatorButton* button)
+      : button_(button) {}
+  ~FadeAnimationDelegate() override {}
+
+ private:
+  // gfx::AnimationDelegate
+  void AnimationProgressed(const gfx::Animation* animation) override {
+    button_->SchedulePaint();
+  }
+
+  void AnimationCanceled(const gfx::Animation* animation) override {
+    AnimationEnded(animation);
+  }
+
+  void AnimationEnded(const gfx::Animation* animation) override {
+    button_->showing_alert_state_ = button_->alert_state_;
+    button_->SchedulePaint();
+    button_->parent_tab_->AlertStateChanged();
+  }
+
+  AlertIndicatorButton* const button_;
+
+  DISALLOW_COPY_AND_ASSIGN(FadeAnimationDelegate);
+};
+
+AlertIndicatorButton::AlertIndicatorButton(Tab* parent_tab)
+    : views::ImageButton(nullptr),
+      parent_tab_(parent_tab) {
+  DCHECK(parent_tab_);
+  SetEventTargeter(
+      std::unique_ptr<views::ViewTargeter>(new views::ViewTargeter(this)));
+
+  // Disable animations of hover state change, to be consistent with the
+  // behavior of the tab close button.
+  set_animate_on_state_change(false);
+}
+
+AlertIndicatorButton::~AlertIndicatorButton() {}
+
+void AlertIndicatorButton::TransitionToAlertState(
+    base::Optional<TabAlertState> next_state) {
+  if (next_state == alert_state_)
+    return;
+
+  base::Optional<TabAlertState> previous_alert_showing_state =
+      showing_alert_state_;
+
+  if (next_state)
+    ResetImages(next_state.value());
+
+  if ((alert_state_ == TabAlertState::AUDIO_PLAYING &&
+       next_state == TabAlertState::AUDIO_MUTING) ||
+      (alert_state_ == TabAlertState::AUDIO_MUTING &&
+       next_state == TabAlertState::AUDIO_PLAYING)) {
+    // Instant user feedback: No fade animation.
+    showing_alert_state_ = next_state;
+    fade_animation_.reset();
+  } else {
+    if (!next_state)
+      showing_alert_state_ = alert_state_;  // Fading-out indicator.
+    else
+      showing_alert_state_ = next_state;  // Fading-in to next indicator.
+    fade_animation_ = CreateTabAlertIndicatorFadeAnimation(next_state);
+    if (!fade_animation_delegate_)
+      fade_animation_delegate_ = std::make_unique<FadeAnimationDelegate>(this);
+    fade_animation_->set_delegate(fade_animation_delegate_.get());
+    fade_animation_->Start();
+  }
+
+  alert_state_ = next_state;
+
+  if (previous_alert_showing_state != showing_alert_state_)
+    parent_tab_->AlertStateChanged();
+
+  UpdateEnabledForMuteToggle();
+}
+
+void AlertIndicatorButton::UpdateEnabledForMuteToggle() {
+  const bool was_enabled = GetEnabled();
+
+  bool enable = AreExperimentalMuteControlsEnabled() &&
+                (alert_state_ == TabAlertState::AUDIO_PLAYING ||
+                 alert_state_ == TabAlertState::AUDIO_MUTING);
+
+  // If the tab is not the currently-active tab, make sure it is wide enough
+  // before enabling click-to-mute.  This ensures that there is enough click
+  // area for the user to activate a tab rather than unintentionally muting it.
+  // Note that IsTriggerableEvent() is also overridden to provide an even wider
+  // requirement for tap gestures.
+  if (enable && !GetTab()->IsActive()) {
+    const int required_width = width() * kMinMouseSelectableAreaPercent / 100;
+    enable = (GetTab()->GetWidthOfLargestSelectableRegion() >= required_width);
+  }
+
+  if (enable == was_enabled)
+    return;
+
+  SetEnabled(enable);
+
+  // If the button has become enabled, check whether the mouse is currently
+  // hovering.  If it is, enter a dormant period where extra user clicks are
+  // prevented from having an effect (i.e., before the user has realized the
+  // button has become enabled underneath their cursor).
+  if (!was_enabled && state() == views::Button::STATE_HOVERED)
+    EnterDormantPeriod();
+  else if (!GetEnabled())
+    ExitDormantPeriod();
+}
+
+void AlertIndicatorButton::OnParentTabButtonColorChanged() {
+  if (alert_state_ == TabAlertState::AUDIO_PLAYING ||
+      alert_state_ == TabAlertState::AUDIO_MUTING)
+    ResetImages(alert_state_);
+}
+
+const char* AlertIndicatorButton::GetClassName() const {
+  return kViewClassName;
+}
+
+views::View* AlertIndicatorButton::GetTooltipHandlerForPoint(
+    const gfx::Point& point) {
+  return nullptr;  // Tab (the parent View) provides the tooltip.
+}
+
+bool AlertIndicatorButton::OnMousePressed(const ui::MouseEvent& event) {
+  // Do not handle this mouse event when anything but the left mouse button is
+  // pressed or when any modifier keys are being held down.  Instead, the Tab
+  // should react (e.g., middle-click for close, right-click for context menu).
+  if (!event.IsOnlyLeftMouseButton() || IsShiftOrControlDown(event)) {
+    if (state() != views::Button::STATE_DISABLED)
+      SetState(views::Button::STATE_NORMAL);  // Turn off hover.
+    return false;  // Event to be handled by Tab.
+  }
+  return ImageButton::OnMousePressed(event);
+}
+
+bool AlertIndicatorButton::OnMouseDragged(const ui::MouseEvent& event) {
+  const ButtonState previous_state = state();
+  const bool ret = ImageButton::OnMouseDragged(event);
+  return ret;
+}
+
+void AlertIndicatorButton::OnMouseEntered(const ui::MouseEvent& event) {
+  // If any modifier keys are being held down, do not turn on hover.
+  if (state() != views::Button::STATE_DISABLED && IsShiftOrControlDown(event)) {
+    SetState(views::Button::STATE_NORMAL);
+    return;
+  }
+  ImageButton::OnMouseEntered(event);
+}
+
+void AlertIndicatorButton::OnMouseExited(const ui::MouseEvent& event) {
+  ExitDormantPeriod();
+  ImageButton::OnMouseExited(event);
+}
+
+void AlertIndicatorButton::OnMouseMoved(const ui::MouseEvent& event) {
+  // If any modifier keys are being held down, turn off hover.
+  if (state() != views::Button::STATE_DISABLED && IsShiftOrControlDown(event)) {
+    SetState(views::Button::STATE_NORMAL);
+    return;
+  }
+  ImageButton::OnMouseMoved(event);
+}
+
+void AlertIndicatorButton::OnBoundsChanged(const gfx::Rect& previous_bounds) {
+  UpdateEnabledForMuteToggle();
+}
+
+bool AlertIndicatorButton::DoesIntersectRect(const views::View* target,
+                                             const gfx::Rect& rect) const {
+  // If this button is not enabled, Tab (the parent View) handles all mouse
+  // events.
+  return GetEnabled() &&
+         views::ViewTargeterDelegate::DoesIntersectRect(target, rect);
+}
+
+void AlertIndicatorButton::NotifyClick(const ui::Event& event) {
+  EnterDormantPeriod();
+
+  // Call TransitionToAlertState() to change the image, providing the user with
+  // instant feedback.  In the very unlikely event that the mute toggle fails,
+  // TransitionToAlertState() will be called again, via another code path, to
+  // set the image to be consistent with the final outcome.
+  if (alert_state_ == TabAlertState::AUDIO_PLAYING) {
+    TransitionToAlertState(TabAlertState::AUDIO_MUTING);
+  } else {
+    DCHECK(alert_state_ == TabAlertState::AUDIO_MUTING);
+    TransitionToAlertState(TabAlertState::AUDIO_PLAYING);
+  }
+
+  GetTab()->controller()->ToggleTabAudioMute(GetTab());
+}
+
+bool AlertIndicatorButton::IsTriggerableEvent(const ui::Event& event) {
+  if (is_dormant())
+    return false;
+
+  // For mouse events, only trigger on the left mouse button and when no
+  // modifier keys are being held down.
+  if (event.IsMouseEvent() &&
+      (!static_cast<const ui::MouseEvent*>(&event)->IsOnlyLeftMouseButton() ||
+       IsShiftOrControlDown(event)))
+    return false;
+
+  // For gesture events on an inactive tab, require an even wider tab before
+  // click-to-mute can be triggered.  See comments in
+  // UpdateEnabledForMuteToggle().
+  if (event.IsGestureEvent() && !GetTab()->IsActive()) {
+    const int required_width = width() * kMinGestureSelectableAreaPercent / 100;
+    if (GetTab()->GetWidthOfLargestSelectableRegion() < required_width)
+      return false;
+  }
+
+  return views::ImageButton::IsTriggerableEvent(event);
+}
+
+void AlertIndicatorButton::PaintButtonContents(gfx::Canvas* canvas) {
+  double opaqueness = 1.0;
+  if (fade_animation_) {
+    opaqueness = fade_animation_->GetCurrentValue();
+    if (!alert_state_)
+      opaqueness = 1.0 - opaqueness;  // Fading out, not in.
+  } else if (is_dormant()) {
+    opaqueness = 0.5;
+  }
+  if (opaqueness < 1.0)
+    canvas->SaveLayerAlpha(opaqueness * SK_AlphaOPAQUE);
+  ImageButton::PaintButtonContents(canvas);
+  if (opaqueness < 1.0)
+    canvas->Restore();
+}
+
+gfx::ImageSkia AlertIndicatorButton::GetImageToPaint() {
+  if (is_dormant())
+    return views::ImageButton::images_[views::Button::STATE_NORMAL];
+  return views::ImageButton::GetImageToPaint();
+}
+
+Tab* AlertIndicatorButton::GetTab() const {
+  DCHECK_EQ(static_cast<views::View*>(parent_tab_), parent());
+  return parent_tab_;
+}
+
+void AlertIndicatorButton::ResetImages(base::Optional<TabAlertState> state) {
+  SkColor color = parent_tab_->GetAlertIndicatorColor(state.value());
+  gfx::ImageSkia indicator_image =
+      GetTabAlertIndicatorImage(state.value(), color).AsImageSkia();
+  SetImage(views::Button::STATE_NORMAL, &indicator_image);
+  SetImage(views::Button::STATE_DISABLED, &indicator_image);
+  gfx::ImageSkia affordance_image =
+      GetTabAlertIndicatorAffordanceImage(state.value(), color).AsImageSkia();
+  SetImage(views::Button::STATE_HOVERED, &affordance_image);
+  SetImage(views::Button::STATE_PRESSED, &affordance_image);
+}
+
+void AlertIndicatorButton::EnterDormantPeriod() {
+  wake_up_timer_.reset(new base::OneShotTimer());
+  wake_up_timer_->Start(
+      FROM_HERE,
+      base::TimeDelta::FromMilliseconds(views::GetDoubleClickInterval()),
+      this,
+      &AlertIndicatorButton::ExitDormantPeriod);
+  SchedulePaint();
+}
+
+void AlertIndicatorButton::ExitDormantPeriod() {
+  const bool needs_repaint = is_dormant();
+  wake_up_timer_.reset();
+  if (needs_repaint)
+    SchedulePaint();
+}
