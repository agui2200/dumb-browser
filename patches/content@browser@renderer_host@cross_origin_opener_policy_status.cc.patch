diff --git a/content/browser/renderer_host/cross_origin_opener_policy_status.cc b/content/browser/renderer_host/cross_origin_opener_policy_status.cc
index 6665adb46aa7..54a9943152eb 100644
--- a/content/browser/renderer_host/cross_origin_opener_policy_status.cc
+++ b/content/browser/renderer_host/cross_origin_opener_policy_status.cc
@@ -143,93 +143,13 @@ CrossOriginOpenerPolicyStatus::EnforceCOOP(
         kCoopSandboxedIFrameCannotNavigateToCoopPage;
   }
 
-  StoragePartition* storage_partition = frame_tree_node_->current_frame_host()
-                                            ->GetProcess()
-                                            ->GetStoragePartition();
-  auto response_reporter = std::make_unique<CrossOriginOpenerPolicyReporter>(
-      storage_partition, response_url, response_referrer_url, response_coop,
-      network_isolation_key);
-  CrossOriginOpenerPolicyReporter* previous_reporter =
-      use_current_document_coop_reporter_
-          ? frame_tree_node_->current_frame_host()->coop_reporter()
-          : coop_reporter_.get();
-
   bool cross_origin_policy_swap =
       ShouldSwapBrowsingInstanceForCrossOriginOpenerPolicy(
           current_coop_.value, current_origin_, is_initial_navigation_,
           response_coop.value, response_origin);
 
-  // Both report only cases (navigation from and to document) use the following
-  // result, computing the need of a browsing context group swap based on both
-  // documents' report-only values.
-  bool report_only_coop_swap =
-      ShouldSwapBrowsingInstanceForCrossOriginOpenerPolicy(
-          current_coop_.report_only_value, current_origin_,
-          is_initial_navigation_, response_coop.report_only_value,
-          response_origin);
-
-  bool navigating_to_report_only_coop_swap =
-      ShouldSwapBrowsingInstanceForCrossOriginOpenerPolicy(
-          current_coop_.value, current_origin_, is_initial_navigation_,
-          response_coop.report_only_value, response_origin);
-
-  bool navigating_from_report_only_coop_swap =
-      ShouldSwapBrowsingInstanceForCrossOriginOpenerPolicy(
-          current_coop_.report_only_value, current_origin_,
-          is_initial_navigation_, response_coop.value, response_origin);
-
-  bool has_other_window_in_browsing_context_group =
-      frame_tree_node_->current_frame_host()
-          ->delegate()
-          ->GetActiveTopLevelDocumentsInBrowsingContextGroup(
-              frame_tree_node_->current_frame_host())
-          .size() > 1;
-
   if (cross_origin_policy_swap) {
     require_browsing_instance_swap_ = true;
-
-    // If this response's COOP causes a BrowsingInstance swap that severs
-    // communication with another page, report this to the previous COOP
-    // reporter and/or the COOP reporter of the response if they exist.
-    if (has_other_window_in_browsing_context_group) {
-      response_reporter->QueueNavigationToCOOPReport(
-          current_url_, current_origin_.IsSameOriginWith(response_origin),
-          false /* is_report_only */);
-
-      if (previous_reporter) {
-        previous_reporter->QueueNavigationAwayFromCOOPReport(
-            response_url, is_navigation_source_,
-            current_origin_.IsSameOriginWith(response_origin),
-            false /* is_report_only */);
-      }
-    }
-  }
-
-  bool virtual_browsing_instance_swap =
-      report_only_coop_swap && (navigating_to_report_only_coop_swap ||
-                                navigating_from_report_only_coop_swap);
-  if (virtual_browsing_instance_swap) {
-    // If this response's report-only COOP would cause a BrowsingInstance swap
-    // that would sever communication with another page, report this to the
-    // previous COOP reporter and/or the COOP reporter of the response if they
-    // exist.
-    if (has_other_window_in_browsing_context_group) {
-      response_reporter->QueueNavigationToCOOPReport(
-          current_url_, current_origin_.IsSameOriginWith(response_origin),
-          true /* is_report_only */);
-
-      if (previous_reporter) {
-        previous_reporter->QueueNavigationAwayFromCOOPReport(
-            response_url, is_navigation_source_,
-            current_origin_.IsSameOriginWith(response_origin),
-            true /* is_report_only */);
-      }
-    }
-  }
-
-  if (require_browsing_instance_swap_ || virtual_browsing_instance_swap) {
-    virtual_browsing_context_group_ =
-        CrossOriginOpenerPolicyReporter::NextVirtualBrowsingContextGroup();
   }
 
   // Finally, update the current COOP, origin and reporter to those of the
@@ -237,7 +157,6 @@ CrossOriginOpenerPolicyStatus::EnforceCOOP(
   current_coop_ = response_coop;
   current_origin_ = response_origin;
   current_url_ = response_url;
-  coop_reporter_ = std::move(response_reporter);
 
   // Once a response has been received, reports will be sent to the reporter of
   // the last response received.
@@ -250,15 +169,8 @@ CrossOriginOpenerPolicyStatus::EnforceCOOP(
   return base::nullopt;
 }
 
-std::unique_ptr<CrossOriginOpenerPolicyReporter>
-CrossOriginOpenerPolicyStatus::TakeCoopReporter() {
-  return std::move(coop_reporter_);
-}
-
 void CrossOriginOpenerPolicyStatus::UpdateReporterStoragePartition(
     StoragePartition* storage_partition) {
-  if (coop_reporter_)
-    coop_reporter_->set_storage_partition(storage_partition);
 }
 
 // We blank out the COOP headers in a number of situations.
