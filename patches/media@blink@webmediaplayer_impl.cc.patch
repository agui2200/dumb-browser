diff --git a/media/blink/webmediaplayer_impl.cc b/media/blink/webmediaplayer_impl.cc
index 8e07393dccd3..0a3a46eb81d9 100644
--- a/media/blink/webmediaplayer_impl.cc
+++ b/media/blink/webmediaplayer_impl.cc
@@ -58,7 +58,6 @@
 #include "media/remoting/remoting_constants.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
 #include "net/base/data_url.h"
-#include "third_party/blink/public/common/media/watch_time_reporter.h"
 #include "third_party/blink/public/platform/web_encrypted_media_types.h"
 #include "third_party/blink/public/platform/web_fullscreen_video_status.h"
 #include "third_party/blink/public/platform/web_media_player_client.h"
@@ -357,7 +356,6 @@ WebMediaPlayerImpl::WebMediaPlayerImpl(
       create_bridge_callback_(params->create_bridge_callback()),
       request_routing_token_cb_(params->request_routing_token_cb()),
       overlay_routing_token_(OverlayInfo::RoutingToken()),
-      media_metrics_provider_(params->take_metrics_provider()),
       is_background_suspend_enabled_(params->IsBackgroundSuspendEnabled()),
       is_background_video_playback_enabled_(
           params->IsBackgroundVideoPlaybackEnabled()),
@@ -454,13 +452,6 @@ WebMediaPlayerImpl::WebMediaPlayerImpl(
       base::BindRepeating(&WebMediaPlayerImpl::OnMainThreadMemoryDump,
                           weak_this_, media_log_->id()));
 
-  media_metrics_provider_->AcquirePlaybackEventsRecorder(
-      playback_events_recorder_.BindNewPipeAndPassReceiver());
-
-  // MediaMetricsProvider may drop the request for PlaybackEventsRecorder if
-  // it's not interested in recording these events.
-  playback_events_recorder_.reset_on_disconnect();
-
 #if defined(OS_ANDROID)
   renderer_factory_selector_->SetRemotePlayStateChangeCB(
       BindToCurrentLoop(base::BindRepeating(
@@ -485,9 +476,6 @@ WebMediaPlayerImpl::~WebMediaPlayerImpl() {
   delegate_->RemoveObserver(delegate_id_);
   delegate_ = nullptr;
 
-  // Finalize any watch time metrics before destroying the pipeline.
-  watch_time_reporter_.reset();
-
   // Unregister dump providers on their corresponding threads.
   media_task_runner_->DeleteSoon(FROM_HERE,
                                  std::move(media_thread_mem_dumper_));
@@ -682,13 +670,6 @@ void WebMediaPlayerImpl::SetIsEffectivelyFullscreen(
 }
 
 void WebMediaPlayerImpl::OnHasNativeControlsChanged(bool has_native_controls) {
-  if (!watch_time_reporter_)
-    return;
-
-  if (has_native_controls)
-    watch_time_reporter_->OnNativeControlsEnabled();
-  else
-    watch_time_reporter_->OnNativeControlsDisabled();
 }
 
 void WebMediaPlayerImpl::OnDisplayTypeChanged(blink::DisplayType display_type) {
@@ -700,19 +681,12 @@ void WebMediaPlayerImpl::OnDisplayTypeChanged(blink::DisplayType display_type) {
                        display_type == blink::DisplayType::kPictureInPicture));
   }
 
-  if (!watch_time_reporter_)
-    return;
-
   switch (display_type) {
     case blink::DisplayType::kInline:
-      watch_time_reporter_->OnDisplayTypeInline();
       break;
     case blink::DisplayType::kFullscreen:
-      watch_time_reporter_->OnDisplayTypeFullscreen();
       break;
     case blink::DisplayType::kPictureInPicture:
-      watch_time_reporter_->OnDisplayTypePictureInPicture();
-
       // Resumes playback if it was paused when hidden.
       if (paused_when_hidden_) {
         paused_when_hidden_ = false;
@@ -781,11 +755,6 @@ void WebMediaPlayerImpl::DoLoad(LoadType load_type,
   if (smoothness_helper_)
     smoothness_helper_.reset();
 
-  media_metrics_provider_->Initialize(
-      load_type == kLoadTypeMediaSource,
-      load_type == kLoadTypeURL ? blink::GetMediaURLScheme(loaded_url_)
-                                : mojom::MediaURLScheme::kUnknown);
-
   if (demuxer_override_ || load_type == kLoadTypeMediaSource) {
     // If a demuxer override was specified or a Media Source pipeline will be
     // used, the pipeline can start immediately.
@@ -859,24 +828,7 @@ void WebMediaPlayerImpl::Play() {
   // Try to create the smoothness helper, in case we were paused before.
   UpdateSmoothnessHelper();
 
-  if (playback_events_recorder_)
-    playback_events_recorder_->OnPlaying();
-
-  watch_time_reporter_->SetAutoplayInitiated(client_->WasAutoplayInitiated());
-
-  // If we're seeking we'll trigger the watch time reporter upon seek completed;
-  // we don't want to start it here since the seek time is unstable. E.g., when
-  // playing content with a positive start time we would have a zero seek time.
-  if (!Seeking()) {
-    DCHECK(watch_time_reporter_);
-    watch_time_reporter_->OnPlaying();
-  }
-
-  if (video_decode_stats_reporter_)
-    video_decode_stats_reporter_->OnPlaying();
-
   simple_watch_timer_.Start();
-  media_metrics_provider_->SetHasPlayed();
   media_log_->AddEvent<MediaLogEvent::kPlay>();
 
   MaybeUpdateBufferSizesForPlayback();
@@ -913,15 +865,6 @@ void WebMediaPlayerImpl::Pause() {
   if (observer_)
     observer_->OnPaused();
 
-  if (playback_events_recorder_)
-    playback_events_recorder_->OnPaused();
-
-  DCHECK(watch_time_reporter_);
-  watch_time_reporter_->OnPaused();
-
-  if (video_decode_stats_reporter_)
-    video_decode_stats_reporter_->OnPaused();
-
   simple_watch_timer_.Stop();
   media_log_->AddEvent<MediaLogEvent::kPause>();
 
@@ -968,14 +911,6 @@ void WebMediaPlayerImpl::DoSeek(base::TimeDelta time, bool time_updated) {
     return;
   }
 
-  if (playback_events_recorder_)
-    playback_events_recorder_->OnSeeking();
-
-  // Call this before setting |seeking_| so that the current media time can be
-  // recorded by the reporter.
-  if (watch_time_reporter_)
-    watch_time_reporter_->OnSeeking();
-
   // Send the seek updates only when the seek pipeline hasn't started,
   // OnPipelineSeeked is not called yet.
   if (!seeking_)
@@ -1019,8 +954,6 @@ void WebMediaPlayerImpl::SetVolume(double volume) {
   DCHECK(main_task_runner_->BelongsToCurrentThread());
   volume_ = volume;
   pipeline_controller_->SetVolume(volume_ * volume_multiplier_);
-  if (watch_time_reporter_)
-    watch_time_reporter_->OnVolumeChange(volume);
   client_->DidPlayerMutedStatusChange(volume == 0.0);
 
   if (delegate_has_audio_ != HasUnmutedAudio()) {
@@ -1549,15 +1482,10 @@ void WebMediaPlayerImpl::OnEncryptedMediaInitData(
   const bool was_encrypted = is_encrypted_;
   is_encrypted_ = true;
   if (!was_encrypted) {
-    media_metrics_provider_->SetIsEME();
-    if (watch_time_reporter_)
-      CreateWatchTimeReporter();
-
     // |was_encrypted| = false means we didn't have a CDM prior to observing
     // encrypted media init data. Reset the reporter until the CDM arrives. See
     // SetCdmInternal().
     DCHECK(!cdm_config_);
-    video_decode_stats_reporter_.reset();
   }
 
   encrypted_client_->Encrypted(
@@ -1610,9 +1538,6 @@ void WebMediaPlayerImpl::SetCdmInternal(
 
   // Recreate the watch time reporter if necessary.
   if (!was_encrypted) {
-    media_metrics_provider_->SetIsEME();
-    if (watch_time_reporter_)
-      CreateWatchTimeReporter();
   }
 
   WebContentDecryptionModuleImpl* web_cdm =
@@ -1682,10 +1607,6 @@ void WebMediaPlayerImpl::OnPipelineSeeked(bool time_updated) {
   if (paused_) {
     paused_time_ = pipeline_controller_->GetMediaTime();
   } else {
-    DCHECK(watch_time_reporter_);
-    watch_time_reporter_->OnPlaying();
-    if (playback_events_recorder_)
-      playback_events_recorder_->OnPlaying();
   }
   if (time_updated)
     should_notify_time_changed_ = true;
@@ -1919,11 +1840,6 @@ void WebMediaPlayerImpl::OnError(PipelineStatus status) {
   MaybeSetContainerNameForMetrics();
   simple_watch_timer_.Stop();
   media_log_->NotifyError(status);
-  media_metrics_provider_->OnError(status);
-  if (playback_events_recorder_)
-    playback_events_recorder_->OnError(status);
-  if (watch_time_reporter_)
-    watch_time_reporter_->OnError(status);
 
   if (ready_state_ == WebMediaPlayer::kReadyStateHaveNothing) {
     // Any error that occurs before reaching ReadyStateHaveMetadata should
@@ -1952,9 +1868,6 @@ void WebMediaPlayerImpl::OnEnded() {
   ended_ = true;
   client_->TimeChanged();
 
-  if (playback_events_recorder_)
-    playback_events_recorder_->OnEnded();
-
   // We don't actually want this to run until |client_| calls seek() or pause(),
   // but that should have already happened in timeChanged() and so this is
   // expected to be a no-op.
@@ -1968,7 +1881,6 @@ void WebMediaPlayerImpl::OnMetadata(const PipelineMetadata& metadata) {
   // Cache the |time_to_metadata_| to use for adjusting the TimeToFirstFrame and
   // TimeToPlayReady metrics later if we end up doing a suspended startup.
   time_to_metadata_ = base::TimeTicks::Now() - load_start_time_;
-  media_metrics_provider_->SetTimeToMetadata(time_to_metadata_);
   RecordTimingUMA("Media.TimeToMetadata", time_to_metadata_);
 
   MaybeSetContainerNameForMetrics();
@@ -1983,13 +1895,11 @@ void WebMediaPlayerImpl::OnMetadata(const PipelineMetadata& metadata) {
       VIDEO_ROTATION_MAX + 1);
 
   if (HasAudio()) {
-    media_metrics_provider_->SetHasAudio(metadata.audio_decoder_config.codec());
     RecordEncryptionScheme("Audio",
                            metadata.audio_decoder_config.encryption_scheme());
   }
 
   if (HasVideo()) {
-    media_metrics_provider_->SetHasVideo(metadata.video_decoder_config.codec());
     RecordEncryptionScheme("Video",
                            metadata.video_decoder_config.encryption_scheme());
 
@@ -2045,7 +1955,6 @@ void WebMediaPlayerImpl::OnMetadata(const PipelineMetadata& metadata) {
   // TODO(dalecurtis): Don't create these until kReadyStateHaveFutureData; when
   // we create them early we just increase the chances of needing to throw them
   // away unnecessarily.
-  CreateWatchTimeReporter();
   CreateVideoDecodeStatsReporter();
 
   // SetReadyState() may trigger all sorts of calls into this class (e.g.,
@@ -2129,29 +2038,6 @@ void WebMediaPlayerImpl::CreateVideoDecodeStatsReporter() {
   } else if (cdm_config_) {
     DCHECK(!key_system_.empty());
   }
-
-  mojo::PendingRemote<mojom::VideoDecodeStatsRecorder> recorder;
-  media_metrics_provider_->AcquireVideoDecodeStatsRecorder(
-      recorder.InitWithNewPipeAndPassReceiver());
-
-  // Create capabilities reporter and synchronize its initial state.
-  video_decode_stats_reporter_ = std::make_unique<VideoDecodeStatsReporter>(
-      std::move(recorder),
-      base::BindRepeating(&WebMediaPlayerImpl::GetPipelineStatistics,
-                          base::Unretained(this)),
-      pipeline_metadata_.video_decoder_config.profile(),
-      pipeline_metadata_.natural_size, key_system_, cdm_config_,
-      frame_->GetTaskRunner(blink::TaskType::kInternalMedia));
-
-  if (delegate_->IsFrameHidden())
-    video_decode_stats_reporter_->OnHidden();
-  else
-    video_decode_stats_reporter_->OnShown();
-
-  if (paused_)
-    video_decode_stats_reporter_->OnPaused();
-  else
-    video_decode_stats_reporter_->OnPlaying();
 }
 
 void WebMediaPlayerImpl::OnProgress() {
@@ -2209,9 +2095,6 @@ void WebMediaPlayerImpl::OnBufferingStateChangeInternal(
       SerializableBufferingState<SerializableBufferingStateType::kPipeline>{
           state, reason, for_suspended_start});
 
-  if (state == BUFFERING_HAVE_ENOUGH && !for_suspended_start)
-    media_metrics_provider_->SetHaveEnough();
-
   if (state == BUFFERING_HAVE_ENOUGH) {
     TRACE_EVENT1("media", "WebMediaPlayerImpl::BufferingHaveEnough", "id",
                  media_log_->id());
@@ -2222,7 +2105,6 @@ void WebMediaPlayerImpl::OnBufferingStateChangeInternal(
       DCHECK(!for_suspended_start);
       have_reported_time_to_play_ready_ = true;
       const base::TimeDelta elapsed = base::TimeTicks::Now() - load_start_time_;
-      media_metrics_provider_->SetTimeToPlayReady(elapsed);
       RecordTimingUMA("Media.TimeToPlayReady", elapsed);
     }
 
@@ -2257,12 +2139,8 @@ void WebMediaPlayerImpl::OnBufferingStateChangeInternal(
     if (underflow_timer_) {
       auto elapsed = underflow_timer_->Elapsed();
       RecordUnderflowDuration(elapsed);
-      watch_time_reporter_->OnUnderflowComplete(elapsed);
       underflow_timer_.reset();
     }
-
-    if (playback_events_recorder_)
-      playback_events_recorder_->OnBufferingComplete();
   } else {
     // Buffering has underflowed.
     DCHECK_EQ(state, BUFFERING_HAVE_NOTHING);
@@ -2273,11 +2151,7 @@ void WebMediaPlayerImpl::OnBufferingStateChangeInternal(
     if (ready_state_ == WebMediaPlayer::kReadyStateHaveEnoughData &&
         !seeking_) {
       underflow_timer_ = std::make_unique<base::ElapsedTimer>();
-      watch_time_reporter_->OnUnderflow();
       client_->DidBufferUnderflow();
-
-      if (playback_events_recorder_)
-        playback_events_recorder_->OnBuffering();
     }
 
     // It shouldn't be possible to underflow if we've not advanced past
@@ -2315,9 +2189,6 @@ void WebMediaPlayerImpl::OnDurationChange() {
   delegate_->DidMediaMetadataChange(
       delegate_id_, delegate_has_audio_, HasVideo(),
       DurationToMediaContentType(GetPipelineMediaDuration()));
-
-  if (watch_time_reporter_)
-    watch_time_reporter_->OnDurationChanged(GetPipelineMediaDuration());
 }
 
 void WebMediaPlayerImpl::OnAddTextTrack(const TextTrackConfig& config,
@@ -2386,21 +2257,6 @@ void WebMediaPlayerImpl::OnVideoNaturalSizeChange(const gfx::Size& size) {
 
   pipeline_metadata_.natural_size = rotated_size;
 
-  if (using_media_player_renderer_ && old_size.IsEmpty()) {
-    // If we are using MediaPlayerRenderer and this is the first size change, we
-    // now know that there is a video track. This condition is paired with code
-    // in CreateWatchTimeReporter() that guesses the existence of a video track.
-    CreateWatchTimeReporter();
-  } else {
-    UpdateSecondaryProperties();
-  }
-
-  if (video_decode_stats_reporter_ &&
-      !video_decode_stats_reporter_->MatchesBucketedNaturalSize(
-          pipeline_metadata_.natural_size)) {
-    CreateVideoDecodeStatsReporter();
-  }
-
   // Create or replace the smoothness helper now that we have a size.
   UpdateSmoothnessHelper();
 
@@ -2436,39 +2292,20 @@ void WebMediaPlayerImpl::OnAudioConfigChange(const AudioDecoderConfig& config) {
   DCHECK(main_task_runner_->BelongsToCurrentThread());
   DCHECK_NE(ready_state_, WebMediaPlayer::kReadyStateHaveNothing);
 
-  const bool codec_change =
-      pipeline_metadata_.audio_decoder_config.codec() != config.codec();
-  const bool codec_profile_change =
-      pipeline_metadata_.audio_decoder_config.profile() != config.profile();
-
   pipeline_metadata_.audio_decoder_config = config;
 
   if (observer_)
     observer_->OnMetadataChanged(pipeline_metadata_);
-
-  if (codec_change || codec_profile_change)
-    UpdateSecondaryProperties();
 }
 
 void WebMediaPlayerImpl::OnVideoConfigChange(const VideoDecoderConfig& config) {
   DCHECK(main_task_runner_->BelongsToCurrentThread());
   DCHECK_NE(ready_state_, WebMediaPlayer::kReadyStateHaveNothing);
 
-  const bool codec_change =
-      pipeline_metadata_.video_decoder_config.codec() != config.codec();
-  const bool codec_profile_change =
-      pipeline_metadata_.video_decoder_config.profile() != config.profile();
-
   pipeline_metadata_.video_decoder_config = config;
 
   if (observer_)
     observer_->OnMetadataChanged(pipeline_metadata_);
-
-  if (codec_change || codec_profile_change)
-    UpdateSecondaryProperties();
-
-  if (video_decode_stats_reporter_ && codec_profile_change)
-    CreateVideoDecodeStatsReporter();
 }
 
 void WebMediaPlayerImpl::OnVideoAverageKeyframeDistanceUpdate() {
@@ -2476,31 +2313,17 @@ void WebMediaPlayerImpl::OnVideoAverageKeyframeDistanceUpdate() {
 }
 
 void WebMediaPlayerImpl::OnAudioDecoderChange(const PipelineDecoderInfo& info) {
-  media_metrics_provider_->SetAudioPipelineInfo(info);
   if (info.decoder_name == audio_decoder_name_)
     return;
 
   audio_decoder_name_ = info.decoder_name;
-
-  // If there's no current reporter, there's nothing to be done.
-  if (!watch_time_reporter_)
-    return;
-
-  UpdateSecondaryProperties();
 }
 
 void WebMediaPlayerImpl::OnVideoDecoderChange(const PipelineDecoderInfo& info) {
-  media_metrics_provider_->SetVideoPipelineInfo(info);
   if (info.decoder_name == video_decoder_name_)
     return;
 
   video_decoder_name_ = info.decoder_name;
-
-  // If there's no current reporter, there's nothing to be done.
-  if (!watch_time_reporter_)
-    return;
-
-  UpdateSecondaryProperties();
 }
 
 void WebMediaPlayerImpl::OnFrameHidden() {
@@ -2510,12 +2333,6 @@ void WebMediaPlayerImpl::OnFrameHidden() {
   if (IsHidden())
     video_locked_when_paused_when_hidden_ = true;
 
-  if (watch_time_reporter_)
-    watch_time_reporter_->OnHidden();
-
-  if (video_decode_stats_reporter_)
-    video_decode_stats_reporter_->OnHidden();
-
   UpdateBackgroundVideoOptimizationState();
   UpdatePlayState();
 
@@ -2543,12 +2360,6 @@ void WebMediaPlayerImpl::OnFrameShown() {
   // Foreground videos don't require user gesture to continue playback.
   video_locked_when_paused_when_hidden_ = false;
 
-  if (watch_time_reporter_)
-    watch_time_reporter_->OnShown();
-
-  if (video_decode_stats_reporter_)
-    video_decode_stats_reporter_->OnShown();
-
   // Notify the compositor of our page visibility status.
   vfc_task_runner_->PostTask(
       FROM_HERE,
@@ -2624,9 +2435,6 @@ void WebMediaPlayerImpl::FlingingStarted() {
 
   is_flinging_ = true;
 
-  // Capabilities reporting should only be performed for local playbacks.
-  video_decode_stats_reporter_.reset();
-
   // Requests to restart media pipeline. A flinging renderer will be created via
   // the |renderer_factory_selector_|.
   ScheduleRestart();
@@ -2671,7 +2479,6 @@ void WebMediaPlayerImpl::DataSourceInitialized(bool success) {
 
   if (!success) {
     SetNetworkState(WebMediaPlayer::kNetworkStateFormatError);
-    media_metrics_provider_->OnError(PIPELINE_ERROR_NETWORK);
 
     // Not really necessary, since the pipeline was never started, but it at
     // least this makes sure that the error handling code is in sync.
@@ -2840,10 +2647,6 @@ void WebMediaPlayerImpl::StartPipeline() {
     // MediaResource::Type::URL for the moment.
     using_media_player_renderer_ = true;
 
-    // MediaPlayerRenderer does not provide pipeline stats, so nuke capabilities
-    // reporter.
-    video_decode_stats_reporter_.reset();
-
     SetDemuxer(std::make_unique<MediaUrlDemuxer>(
         media_task_runner_, loaded_url_,
         frame_->GetDocument().SiteForCookies().RepresentativeUrl(),
@@ -3368,76 +3171,6 @@ void WebMediaPlayerImpl::ScheduleIdlePauseTimer() {
                                 &blink::WebMediaPlayerClient::ResumePlayback);
 }
 
-void WebMediaPlayerImpl::CreateWatchTimeReporter() {
-  if (!HasVideo() && !HasAudio())
-    return;
-
-  // MediaPlayerRenderer does not know about tracks until playback starts.
-  // Assume audio-only unless the natural size has been detected.
-  bool has_video = pipeline_metadata_.has_video;
-  if (using_media_player_renderer_) {
-    has_video = !pipeline_metadata_.natural_size.IsEmpty();
-  }
-
-  // Create the watch time reporter and synchronize its initial state.
-  watch_time_reporter_ = std::make_unique<blink::WatchTimeReporter>(
-      mojom::PlaybackProperties::New(
-          pipeline_metadata_.has_audio, has_video, false, false,
-          !!chunk_demuxer_, is_encrypted_, embedded_media_experience_enabled_),
-      pipeline_metadata_.natural_size,
-      base::BindRepeating(&WebMediaPlayerImpl::GetCurrentTimeInternal,
-                          base::Unretained(this)),
-      base::BindRepeating(&WebMediaPlayerImpl::GetPipelineStatistics,
-                          base::Unretained(this)),
-      media_metrics_provider_.get(),
-      frame_->GetTaskRunner(blink::TaskType::kInternalMedia));
-  watch_time_reporter_->OnVolumeChange(volume_);
-  watch_time_reporter_->OnDurationChanged(GetPipelineMediaDuration());
-
-  if (delegate_->IsFrameHidden())
-    watch_time_reporter_->OnHidden();
-  else
-    watch_time_reporter_->OnShown();
-
-  if (client_->HasNativeControls())
-    watch_time_reporter_->OnNativeControlsEnabled();
-  else
-    watch_time_reporter_->OnNativeControlsDisabled();
-
-  switch (client_->GetDisplayType()) {
-    case blink::DisplayType::kInline:
-      watch_time_reporter_->OnDisplayTypeInline();
-      break;
-    case blink::DisplayType::kFullscreen:
-      watch_time_reporter_->OnDisplayTypeFullscreen();
-      break;
-    case blink::DisplayType::kPictureInPicture:
-      watch_time_reporter_->OnDisplayTypePictureInPicture();
-      break;
-  }
-
-  UpdateSecondaryProperties();
-
-  // If the WatchTimeReporter was recreated in the middle of playback, we want
-  // to resume playback here too since we won't get another play() call. When
-  // seeking, the seek completion will restart it if necessary.
-  if (!paused_ && !seeking_)
-    watch_time_reporter_->OnPlaying();
-}
-
-void WebMediaPlayerImpl::UpdateSecondaryProperties() {
-  watch_time_reporter_->UpdateSecondaryProperties(
-      mojom::SecondaryPlaybackProperties::New(
-          pipeline_metadata_.audio_decoder_config.codec(),
-          pipeline_metadata_.video_decoder_config.codec(),
-          pipeline_metadata_.audio_decoder_config.profile(),
-          pipeline_metadata_.video_decoder_config.profile(),
-          audio_decoder_name_, video_decoder_name_,
-          pipeline_metadata_.audio_decoder_config.encryption_scheme(),
-          pipeline_metadata_.video_decoder_config.encryption_scheme(),
-          pipeline_metadata_.natural_size));
-}
-
 bool WebMediaPlayerImpl::IsHidden() const {
   DCHECK(main_task_runner_->BelongsToCurrentThread());
 
@@ -3710,9 +3443,6 @@ void WebMediaPlayerImpl::SwitchToRemoteRenderer(
   DCHECK(!disable_pipeline_auto_suspend_);
   disable_pipeline_auto_suspend_ = true;
 
-  // Capabilities reporting should only be performed for local playbacks.
-  video_decode_stats_reporter_.reset();
-
   // Requests to restart media pipeline. A remote renderer will be created via
   // the |renderer_factory_selector_|.
   ScheduleRestart();
@@ -3778,9 +3508,6 @@ void WebMediaPlayerImpl::RecordVideoNaturalSize(const gfx::Size& natural_size) {
     UMA_HISTOGRAM_VIDEO_HEIGHT("Media.VideoHeight.Initial.EME", height);
 
   UMA_HISTOGRAM_VIDEO_HEIGHT("Media.VideoHeight.Initial.All", height);
-
-  if (playback_events_recorder_)
-    playback_events_recorder_->OnNaturalSizeChanged(natural_size);
 }
 
 #undef UMA_HISTOGRAM_VIDEO_HEIGHT
@@ -3797,7 +3524,6 @@ void WebMediaPlayerImpl::OnFirstFrame(base::TimeTicks frame_time) {
   has_first_frame_ = true;
   needs_first_frame_ = false;
   const base::TimeDelta elapsed = frame_time - load_start_time_;
-  media_metrics_provider_->SetTimeToFirstFrame(elapsed);
   RecordTimingUMA("Media.TimeToFirstFrame", elapsed);
 
   // Needed to signal HTMLVideoElement that it should remove the poster image.
@@ -3843,11 +3569,6 @@ void WebMediaPlayerImpl::MaybeSetContainerNameForMetrics() {
   // Container has already been set.
   if (highest_ready_state_ >= WebMediaPlayer::kReadyStateHaveMetadata)
     return;
-
-  // Only report metrics for demuxers that provide container information.
-  auto container = demuxer_->GetContainerForMetrics();
-  if (container.has_value())
-    media_metrics_provider_->SetContainerName(container.value());
 }
 
 void WebMediaPlayerImpl::MaybeUpdateBufferSizesForPlayback() {
@@ -3864,9 +3585,6 @@ void WebMediaPlayerImpl::MaybeUpdateBufferSizesForPlayback() {
 
 void WebMediaPlayerImpl::OnSimpleWatchTimerTick() {
   RecordSimpleWatchTimeUMA(reported_renderer_type_);
-
-  if (playback_events_recorder_)
-    playback_events_recorder_->OnPipelineStatistics(GetPipelineStatistics());
 }
 
 GURL WebMediaPlayerImpl::GetSrcAfterRedirects() {
@@ -3918,8 +3636,6 @@ WebMediaPlayerImpl::GetLearningTaskController(const char* task_name) {
   DCHECK_EQ(task.name, task_name);
 
   mojo::Remote<media::learning::mojom::LearningTaskController> remote_ltc;
-  media_metrics_provider_->AcquireLearningTaskController(
-      task.name, remote_ltc.BindNewPipeAndPassReceiver());
   return std::make_unique<learning::MojoLearningTaskController>(
       task, std::move(remote_ltc));
 }
